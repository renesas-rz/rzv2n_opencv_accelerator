diff --git a/modules/core/include/opencv2/core/base.hpp b/modules/core/include/opencv2/core/base.hpp
index 21a61a4..f9b03c9 100644
--- a/modules/core/include/opencv2/core/base.hpp
+++ b/modules/core/include/opencv2/core/base.hpp
@@ -120,8 +120,9 @@ enum Code {
     OpenCLApiCallError=        -220, //!< OpenCL API call error
     OpenCLDoubleNotSupported=  -221,
     OpenCLInitError=           -222, //!< OpenCL initialization error
-    OpenCLNoAMDBlasFft=        -223
-};
+    OpenCLNoAMDBlasFft=        -223,
+    OpenCVADRPConflict=        -501, //!< OpenCVA DRP conflict error
+    };
 } //Error
 
 //! @} core_utils
diff --git a/modules/features2d/src/fast.cpp b/modules/features2d/src/fast.cpp
index cb088eb..f76f795 100644
--- a/modules/features2d/src/fast.cpp
+++ b/modules/features2d/src/fast.cpp
@@ -51,6 +51,10 @@ The references are:
 
 #include "opencv2/core/openvx/ovx_defs.hpp"
 
+#include "rzv2ma_drp.h"
+#include <unistd.h>
+#include <opencv2/core/utils/logger.hpp>
+
 namespace cv
 {
 
@@ -493,6 +497,154 @@ static inline int hal_FAST(cv::Mat& src, std::vector<KeyPoint>& keypoints, int t
     return CV_HAL_ERROR_OK;
 }
 
+/* function definition description (to avoid warning in build process)*/
+int FAST_drp(InputArray _img, std::vector<KeyPoint> &keypoints, int threshold, bool nonmax_suppression, FastFeatureDetector::DetectorType type);
+
+/*****************************************
+* Method Name   : drp_FAST
+* Description   : to exec drp process of OpenCV accelerator FAST
+* Arguments     : _img = src image (Mat)
+                    keypoints = detected keypoints (vector)
+                    threshold = threshold
+                    nonmax_suppression (bool)
+                    Detector type (DetectorType)
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+******************************************/
+int FAST_drp(InputArray _img, std::vector<KeyPoint> &keypoints, int threshold, bool nonmax_suppression, FastFeatureDetector::DetectorType type)
+{
+    CV_LOG_INFO(nullptr, "FAST_drp start.");
+
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if (NULL == drp)
+    {
+        CV_LOG_INFO(nullptr, "FAST_drp get instance");
+        return DRP_NOT_EXECUTE;
+    }
+
+    int result = DRP_NORMAL_END;
+
+    /* get possible flag */
+    int fast_possiblef = drp->get_drp_possiblef(PARAM_NO_FAST);
+
+    /* active status only */
+    if (fast_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to convert to Mat class */
+    Mat src_mat = _img.getMat();
+
+    /* to set src img spec */
+    uint16_t src_width = src_mat.size().width;
+    uint16_t src_height = src_mat.size().height;
+    uint16_t src_ch = src_mat.channels();
+    uint16_t src_depth = src_mat.depth();
+    
+
+    uint16_t const img_min_width = 16;
+    uint16_t const img_min_height = 16;
+    uint16_t const img_max_width = 3840;
+    uint16_t const img_max_height = 2160;
+    uint16_t const max_threshold = 255;
+    uint16_t const min_threshold = 0;
+
+    /* check src image size */
+    if ((src_width < img_min_width) || (img_max_width < src_width) || (src_width % 2 != 0))
+    {
+        return DRP_NOT_EXECUTE;
+    }
+    if ((src_height < img_min_height) || (img_max_height < src_height) || (src_height % 2 != 0))
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* check channel & depth*/
+    if ((src_ch != 1) || (src_depth != CV_8U))
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* check threshold value */
+    if (((uint16_t)threshold < min_threshold) || (max_threshold < (uint16_t)threshold))
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* check non-max suppression */
+    if (nonmax_suppression != true)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* check detector type */
+    if (type != FastFeatureDetector::TYPE_9_16)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    /* set in process to driver */
+    if (drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if (DRP_NORMAL_END != result)
+    {
+        CV_LOG_INFO(nullptr, "FAST_drp read header error.");
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set FAST parameter */
+    result = drp->setFastParameter(src_width, src_height, src_ch, threshold);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set FAST target image to drp input area */
+    result = drp->setSrcImage(src_mat.data);
+    if (DRP_NORMAL_END != result)
+    {    
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* executing drp process */
+    result = drp->execDRP();
+    if (DRP_NORMAL_END != result)
+    {    
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->readCornerPoints(keypoints);
+
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    CV_LOG_INFO(nullptr, "FAST_drp end.");
+
+    drp->set_drp_end();
+
+    return DRP_NORMAL_END;
+}
+
 void FAST(InputArray _img, std::vector<KeyPoint>& keypoints, int threshold, bool nonmax_suppression, FastFeatureDetector::DetectorType type)
 {
     CV_INSTRUMENT_REGION();
@@ -500,6 +652,16 @@ void FAST(InputArray _img, std::vector<KeyPoint>& keypoints, int threshold, bool
     CV_OCL_RUN(_img.isUMat() && type == FastFeatureDetector::TYPE_9_16,
                ocl_FAST(_img, keypoints, threshold, nonmax_suppression, 10000));
 
+    CV_LOG_INFO(nullptr, "FAST method start.");
+
+    /* Call drp process */ 
+    int result = FAST_drp(_img, keypoints, threshold, nonmax_suppression, type);
+    if(result == DRP_NORMAL_END)
+    {
+        return;
+    }
+
+    /* If could not execute drp process, then to call normal opencv method */
     cv::Mat img = _img.getMat();
     CALL_HAL(fast_dense, hal_FAST, img, keypoints, threshold, nonmax_suppression, type);
 
diff --git b/modules/imgproc/include/drpopencva.h b/modules/imgproc/include/drpopencva.h
new file mode 100644
index 0000000..c421241
--- /dev/null
+++ b/modules/imgproc/include/drpopencva.h
@@ -0,0 +1,87 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * Driver for the Renesas RZ/V2H DRP unit
+ *
+ * Copyright (C) 2021 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _UAPI__DRP_H
+#define _UAPI__DRP_H
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+#include <linux/ioctl.h>
+
+#define DRP_IO_TYPE               (46)
+#define DRP_ASSIGN                _IOW (DRP_IO_TYPE, 0, drp_data_t)
+#define DRP_START                 _IOW (DRP_IO_TYPE, 1, drp_data_t)
+#define DRP_RESET                 _IO  (DRP_IO_TYPE, 2)
+#define DRP_GET_STATUS            _IOR (DRP_IO_TYPE, 3, drp_status_t)
+#define DRP_SET_SEQ               _IOW (DRP_IO_TYPE, 6, drp_seq_t)           /* Since the sturecture size is different,            */
+#define DRP_GET_CODEC_AREA        _IOR (DRP_IO_TYPE, 11, drp_data_t)
+#define DRP_GET_OPENCVA_AREA      _IOR (DRP_IO_TYPE, 12, drp_data_t)
+#define DRP_SET_DRP_FREQ          _IOW (DRP_IO_TYPE, 13, uint32_t)
+
+#define DRP_STATUS_INIT                   (0)
+#define DRP_STATUS_IDLE                   (1)
+#define DRP_STATUS_RUN                    (2)
+#define DRP_ERRINFO_SUCCESS               (0)
+#define DRP_ERRINFO_DRP_ERR               (-1)
+#define DRP_ERRINFO_RESET                 (-3)
+#define DRP_RESERVED_NUM                  (10)
+#define DRP_SEQ_NUM                       (20)
+#define DRP_EXE_DRP_40BIT                 (3)
+#define DRP_OPMASK_FORCE_LOAD             (0x8000)
+#define PARAM_ADDRESS_NUM                 (120)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct drp_data
+{
+    uint64_t        address;
+    uint32_t        size;
+} drp_data_t;
+
+typedef struct drp_status
+{
+    uint32_t        status;
+    int32_t         err;
+    uint32_t        reserved[DRP_RESERVED_NUM];
+} drp_status_t;
+
+typedef struct iodata_info
+{
+    uint64_t        address;
+    uint32_t        size;
+    uint32_t        pos;
+} iodata_info_st;
+
+typedef struct drp_seq
+{
+    uint32_t        num;
+    uint32_t        order[DRP_SEQ_NUM];
+    uint64_t        address;
+    uint32_t        iodata_num;
+    iodata_info_st  iodata[PARAM_ADDRESS_NUM];
+} drp_seq_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _UAPI__DRP_H */
diff --git a/modules/imgproc/include/opencv2/imgproc.hpp b/modules/imgproc/include/opencv2/imgproc.hpp
index c95f1ad..1991699 100644
--- a/modules/imgproc/include/opencv2/imgproc.hpp
+++ b/modules/imgproc/include/opencv2/imgproc.hpp
@@ -686,8 +686,8 @@ enum ColorConversionCodes {
     //! YUV 4:2:2 family to RGB
     COLOR_YUV2RGB_UYVY = 107,
     COLOR_YUV2BGR_UYVY = 108,
-    //COLOR_YUV2RGB_VYUY = 109,
-    //COLOR_YUV2BGR_VYUY = 110,
+    COLOR_YUV2RGB_VYUY = 109,
+    COLOR_YUV2BGR_VYUY = 110,
     COLOR_YUV2RGB_Y422 = COLOR_YUV2RGB_UYVY,
     COLOR_YUV2BGR_Y422 = COLOR_YUV2BGR_UYVY,
     COLOR_YUV2RGB_UYNV = COLOR_YUV2RGB_UYVY,
@@ -695,8 +695,8 @@ enum ColorConversionCodes {
 
     COLOR_YUV2RGBA_UYVY = 111,
     COLOR_YUV2BGRA_UYVY = 112,
-    //COLOR_YUV2RGBA_VYUY = 113,
-    //COLOR_YUV2BGRA_VYUY = 114,
+    COLOR_YUV2RGBA_VYUY = 113,
+    COLOR_YUV2BGRA_VYUY = 114,
     COLOR_YUV2RGBA_Y422 = COLOR_YUV2RGBA_UYVY,
     COLOR_YUV2BGRA_Y422 = COLOR_YUV2BGRA_UYVY,
     COLOR_YUV2RGBA_UYNV = COLOR_YUV2RGBA_UYVY,
@@ -876,7 +876,17 @@ enum ColorConversionCodes {
     COLOR_RGBA2YUV_YUNV = COLOR_RGBA2YUV_YUY2,
     COLOR_BGRA2YUV_YUNV = COLOR_BGRA2YUV_YUY2,
 
-    COLOR_COLORCVT_MAX  = 155
+    COLOR_COLORCVT_MAX  = 155,
+
+    /* opencva drp yuv -> nv */
+    COLOR_YUV_NV12_YUY2 = 0x10000,
+    COLOR_YUV_NV12_YVYU = 0x10001,
+    COLOR_YUV_NV12_UYVY = 0x10002,
+    COLOR_YUV_NV12_VYUY = 0x10003,
+    COLOR_YUV_NV21_YUY2 = 0x10004,
+    COLOR_YUV_NV21_YVYU = 0x10005,
+    COLOR_YUV_NV21_UYVY = 0x10006,
+    COLOR_YUV_NV21_VYUY = 0x10007
 };
 
 //! @addtogroup imgproc_shape
@@ -1548,6 +1558,8 @@ CV_EXPORTS_W void GaussianBlur( InputArray src, OutputArray dst, Size ksize,
                                 double sigmaX, double sigmaY = 0,
                                 int borderType = BORDER_DEFAULT );
 
+CV_EXPORTS_W int GaussianBlur_drp(Mat src_mat, Mat dst_mat, Size ksize, double sigma1, double sigma2, int borderType);
+
 /** @brief Applies the bilateral filter to an image.
 
 The function applies bilateral filtering to the input image, as described in
@@ -1705,6 +1717,10 @@ CV_EXPORTS_W void filter2D( InputArray src, OutputArray dst, int ddepth,
                             InputArray kernel, Point anchor = Point(-1,-1),
                             double delta = 0, int borderType = BORDER_DEFAULT );
 
+CV_EXPORTS_W int filter2D_drp(InputArray _src, OutputArray _dst, int ddepth,
+              InputArray _kernel, Point anchor0,
+              double delta, int borderType);
+
 /** @brief Applies a separable linear filter to an image.
 
 The function applies a separable linear filter to the image. That is, first, every row of src is
@@ -1780,6 +1796,11 @@ CV_EXPORTS_W void Sobel( InputArray src, OutputArray dst, int ddepth,
                          double scale = 1, double delta = 0,
                          int borderType = BORDER_DEFAULT );
 
+CV_EXPORTS_W int Sobel_drp( InputArray src, OutputArray dst, int ddepth,
+                         int dx, int dy, int ksize = 3,
+                         double scale = 1, double delta = 0,
+                         int borderType = BORDER_DEFAULT );
+
 /** @brief Calculates the first order image derivative in both x and y using a Sobel operator
 
 Equivalent to calling:
@@ -2423,6 +2444,9 @@ CV_EXPORTS_W void resize( InputArray src, OutputArray dst,
                           Size dsize, double fx = 0, double fy = 0,
                           int interpolation = INTER_LINEAR );
 
+CV_EXPORTS_W int resize_drp(InputArray _src, OutputArray _dst, Size dsize, double inv_scale_x,
+                          double inv_scale_y, int interpolation);
+
 /** @brief Applies an affine transformation to an image.
 
 The function warpAffine transforms the source image using the specified matrix:
@@ -2453,6 +2477,12 @@ CV_EXPORTS_W void warpAffine( InputArray src, OutputArray dst,
                               int borderMode = BORDER_CONSTANT,
                               const Scalar& borderValue = Scalar());
 
+CV_EXPORTS_W int warpAffine_drp(InputArray src, OutputArray dst,
+                              InputArray M, Size dsize,
+                              int flags = INTER_LINEAR,
+                              int borderMode = BORDER_CONSTANT,
+                              const Scalar& borderValue = Scalar());
+
 /** @example samples/cpp/warpPerspective_demo.cpp
 An example program shows using cv::getPerspectiveTransform and cv::warpPerspective for image warping
 */
@@ -2485,6 +2515,12 @@ CV_EXPORTS_W void warpPerspective( InputArray src, OutputArray dst,
                                    int borderMode = BORDER_CONSTANT,
                                    const Scalar& borderValue = Scalar());
 
+CV_EXPORTS_W int warpPerspective_drp( InputArray src, OutputArray dst,
+                                   InputArray M, Size dsize,
+                                   int flags = INTER_LINEAR,
+                                   int borderMode = BORDER_CONSTANT,
+                                   const Scalar& borderValue = Scalar());
+
 /** @brief Applies a generic geometrical transformation to an image.
 
 The function remap transforms the source image using the specified map:
@@ -2522,6 +2558,11 @@ CV_EXPORTS_W void remap( InputArray src, OutputArray dst,
                          int interpolation, int borderMode = BORDER_CONSTANT,
                          const Scalar& borderValue = Scalar());
 
+CV_EXPORTS_W int remap_drp( InputArray src, OutputArray dst,
+                         InputArray map1, InputArray map2,
+                         int interpolation, int borderMode = BORDER_CONSTANT,
+                         const Scalar& borderValue = Scalar());
+
 /** @brief Converts image transformation maps from one representation to another.
 
 The function converts a pair of maps for remap from one representation to another. The following
@@ -3109,6 +3150,10 @@ CV_EXPORTS_W void adaptiveThreshold( InputArray src, OutputArray dst,
                                      double maxValue, int adaptiveMethod,
                                      int thresholdType, int blockSize, double C );
 
+ CV_EXPORTS_W int adaptiveThreshold_drp( InputArray src, OutputArray dst,
+                                     double maxValue, int adaptiveMethod,
+                                     int thresholdType, int blockSize, double C );
+
 //! @} imgproc_misc
 
 //! @addtogroup imgproc_filter
@@ -3140,6 +3185,9 @@ Then, it downsamples the image by rejecting even rows and columns.
 CV_EXPORTS_W void pyrDown( InputArray src, OutputArray dst,
                            const Size& dstsize = Size(), int borderType = BORDER_DEFAULT );
 
+CV_EXPORTS_W int pyrDown_drp( InputArray src, OutputArray dst,
+                           const Size& dstsize = Size(), int borderType = BORDER_DEFAULT );
+
 /** @brief Upsamples an image and then blurs it.
 
 By default, size of the output image is computed as `Size(src.cols\*2, (src.rows\*2)`, but in any
@@ -3160,6 +3208,9 @@ pyrDown multiplied by 4.
 CV_EXPORTS_W void pyrUp( InputArray src, OutputArray dst,
                          const Size& dstsize = Size(), int borderType = BORDER_DEFAULT );
 
+CV_EXPORTS_W int pyrUp_drp( InputArray src, OutputArray dst,
+                         const Size& dstsize = Size(), int borderType = BORDER_DEFAULT );
+
 /** @brief Constructs the Gaussian pyramid for an image.
 
 The function constructs a vector of images and builds the Gaussian pyramid by recursively applying
@@ -3908,6 +3959,9 @@ is \f$W \times H\f$ and templ is \f$w \times h\f$ , then result is \f$(W-w+1) \t
 CV_EXPORTS_W void matchTemplate( InputArray image, InputArray templ,
                                  OutputArray result, int method, InputArray mask = noArray() );
 
+CV_EXPORTS_W int matchTemplate_drp( InputArray image, InputArray templ,
+                                 OutputArray result, int method, InputArray mask = noArray() );
+
 //! @}
 
 //! @addtogroup imgproc_shape
@@ -5062,6 +5116,11 @@ Point LineIterator::pos() const
 
 } // cv
 
+/* opencva activate api */
+CV_EXPORTS_W int OCA_Activate(unsigned long* OCA_list);
+
+/* opencva conflict action setting api */
+CV_EXPORTS_W void OCA_ConflictNotification(int oca_conflict);
 
 #include "./imgproc/segmentation.hpp"
 
diff --git b/modules/imgproc/include/rzv2ma_drp.h b/modules/imgproc/include/rzv2ma_drp.h
new file mode 100644
index 0000000..0fa9f81
--- /dev/null
+++ b/modules/imgproc/include/rzv2ma_drp.h
@@ -0,0 +1,290 @@
+/***********************************************************************************************************************
+* DISCLAIMER
+* This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products. No
+* other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all
+* applicable laws, including copyright laws.
+* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED. TO THE MAXIMUM
+* EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES
+* SHALL BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS
+* SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+* Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability of
+* this software. By using this software, you agree to the additional terms and conditions found by accessing the
+* following link:
+* http://www.renesas.com/disclaimer
+*
+* Copyright (C) 2022 Renesas Electronics Corporation. All rights reserved.
+***********************************************************************************************************************/
+/***********************************************************************************************************************
+* File Name    : rzv2m_drp.h
+* Version      : 1.00
+* Description  : Call RZ/V2M From OpenCV Accelerator
+***********************************************************************************************************************/
+#ifndef RZV2M_DRP_DEFINE_MACRO_H
+#define RZV2M_DRP_DEFINE_MACRO_H
+
+/* include file */
+#include <drpopencva.h>
+#include <opencv2/core/types.hpp>
+
+/* definition of compile switch flag for rzv2h */
+#define DEV_RZV2H
+
+/* device file names */
+#define DRV_DEV_NAME "/dev/opencva0"
+
+/* device file names */
+/* compile switch */
+#ifdef DEV_RZV2H
+#define DRP_DEV_NAME "/dev/drp1"
+#else
+#define DRP_DEV_NAME "/dev/drp0"
+#endif
+
+/* signature name */
+/* compile switch */
+#ifdef DEV_RZV2H
+#define OCABIN_SIGNATURE "RENESAS OCA V2H"
+#define OCABIN_MAJOR_VER "VER1"
+#else
+#define OCABIN_SIGNATURE "RENESAS OPENCVA"
+#define OCABIN_MAJOR_VER ""
+#endif
+
+/* const values for drp driver */
+#define DRPPARAM1           (1)
+#define DRPCFG_NUM          (1)
+#define DRPCFG1             (0)
+#define PARAM_NO_RESIZE     (0)         // resize circuit no
+#define PARAM_NO_YUV2RGB    (2)         // YUV2RGB circuit no
+#define PARAM_NO_YUV2NV     (3)         // YUV2NV circuit no
+#define PARAM_SIZE_RESIZE   (56)        // param size of resize
+#define PARAM_SIZE_YUV2RGB  (56)        // param size of YUV2RGB
+#define PARAM_SIZE_YUV2NV   (56)        // param size of YUV2RGB
+#define DRP_PARAM_SIZE      (256)       // max size of drp parameter
+
+#define DRP_CIRCUIT_CNT_MAX (1024)      // max circuit count
+#define DRP_EXEC_TIMEOUT_SECONDS (10)   // timeout for drp exec
+
+/* return vallues */
+const static int DRP_NOT_EXECUTE = 1;
+const static int DRP_NORMAL_END = 0;
+const static int DRP_PARAM_ERROR = -1;
+const static int DRP_SRC_IMAGE_ERROR = -2;
+const static int DRP_DST_IMAGE_ERROR = -3;
+const static int DRP_EXEC_ERROR = -4;
+const static int DRP_CONFLICT_ERROR = -5;
+
+/* OCA constant */
+#define OCA_BIN_SIZE          (3686400)   // opencva binary area(400*1024*9 Byte) 
+#define PARAM_NO_YUV2NV12     (3)         // circuit No of YUV to NV12
+#define PARAM_SIZE_YUV2NV12   (56)        // param size of YUV to NV12
+
+#define PARAM_NO_GAUSSIAN     (4)         // circuit No of gaussian
+#define PARAM_SIZE_GAUSSIAN   (56)        // param size of gaussian
+
+#define PARAM_NO_MORPH_DILATE (5)         // circuit No of Morphology dilate
+#define PARAM_NO_MORPH_ERODE  (6)         // circuit No of Morphology erode
+
+#define PARAM_NO_FILTER2D     (7)         // circuit No of Filter2d
+#define PARAM_SIZE_FILTER2D  (88)         // param size of filter2d
+
+#define PARAM_SIZE_MORPHOLOGY (56)        // param size of Morphology
+
+#define PARAM_NO_ATHRESHOLD (9)           // circuit No of AThreshold
+#define PARAM_SIZE_ATHRESHOLD (56)        // param size of AThreshold
+
+#define PARAM_NO_SOBEL (8)                // circuit No of Sobel
+#define PARAM_SIZE_SOBEL (56)             // param size of Sobel
+
+#define PARAM_NO_MATCHTEMPLATE (10)       // circuit No of MatchTemplate
+#define PARAM_SIZE_MATCHTEMPLATE (64)     // param size of MatchTemplate
+
+#define PARAM_NO_WARPAFFINE (11)       // circuit No of warpAffine
+#define PARAM_SIZE_WARPAFFINE (76)     // param size of warpAffine
+
+#define PARAM_NO_PYRDOWN (12)          // circuit No of pyrdown
+#define PARAM_SIZE_PYRDOWN (48)        // param size of pyrDown
+
+#define PARAM_NO_PYRUP (13)          // circuit No of pyrup
+#define PARAM_SIZE_PYRUP (48)        // param size of pyrup
+
+#define PARAM_NO_WARPPERSPECTIVE (14)    // circuit No of warpPerspective
+#define PARAM_SIZE_WARPPERSPECTIVE (88)  // param size of warpPerspective
+
+#define PARAM_NO_FAST (15)   // circuit No of fast
+#define PARAM_SIZE_FAST (56) // param size of fast
+
+#define PARAM_NO_REMAP (16)   // circuit No of remap
+#define PARAM_SIZE_REMAP (56) // param size of remap
+
+/* OCA Circuit activate*/
+/* input param */
+#define CIRCUIT_INPARAM_INACTIVATE (0)
+#define CIRCUIT_INPARAM_ACTIVATE (1)
+
+/* possible flag status */
+#define CIRCUIT_POSSIBLEF_NOT_EXIST (0)
+#define CIRCUIT_POSSIBLEF_ACTIVE (1)
+#define CIRCUIT_POSSIBLEF_INACTIVE (2)
+
+/* drp in process set or reset */
+#define IO_CTL_DRP_START (3)
+#define IO_CTL_DRP_END (4)
+#define IO_CTL_DRP_CONFLICT (-1)
+#define IO_CTL_DRP_CONFLICT_ERR (-2)
+
+/* Unit size of read buffer in FAST */
+#define FAST_READ_BUFFER_SIZE (1000) 
+
+enum DRP_PROCESS_STATUS { 
+    READY,
+    INITIALIZE,
+    READ_HEADER, 
+    SET_PARAMETER,
+    READ_SRC_IMAGE,
+    EXEC_DRP,
+    READ_DST_IMAGE
+};
+
+struct drp_proces_thread_id {
+    uint32_t process_id;
+    uint32_t thread_id;
+};
+
+/*****************************************
+* Class Name   : rzv2m_drp
+* Description  : DRP OpenCV Accelerator class define
+******************************************/
+class rzv2m_drp
+{
+public:
+    rzv2m_drp();
+    ~rzv2m_drp();
+
+    static rzv2m_drp* get_instance();
+    
+    static rzv2m_drp* get_instance_forapi();
+
+    static enum DRP_PROCESS_STATUS process_status;
+
+    static int drp_conflict_exception;
+
+    int readBinaryHeader(void);
+
+    int setResizeParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dst_width, uint16_t dst_height, uint16_t dst_ch);
+
+    int setYUV2RGBParameter(uint16_t src_width, uint16_t src_height, uint32_t input_size, uint16_t input_format,
+                uint16_t dst_width, uint16_t dst_height, uint16_t output_format);
+	
+    int setYUV2NVParameter(uint16_t src_width, uint16_t src_height, uint16_t input_yuv, uint16_t output_nv);
+	
+    int setGaussianParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch, uint16_t kernel_size);
+
+    int setMorphologyParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch, uint16_t iterators,
+                uint16_t border_type, uint16_t border_value, uint16_t morph_circuit_no);
+
+    int setFilter2dParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch, float* filter);
+
+    int setAdaptiveThreshold(uint16_t src_width, uint16_t src_height, uint16_t src_ch, uint16_t max_value, 
+                uint16_t threshold_type, uint32_t block_size, uint16_t threshold_C);
+
+    int setSobelParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch, uint16_t delataXY);
+
+    int setMatchTemplateParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+            uint16_t tmpl_width, uint16_t tmpl_height, uint16_t tmpl_ch, uint16_t method);
+
+    int setWarpAffineParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dst_width, uint16_t dst_height, float* transform_matrix, uint32_t border_value);
+ 
+    int setPyrDownParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dsize_width, uint16_t dsize_height);
+
+    int setPyrUpParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dsize_width, uint16_t dsize_height);
+
+    int setWarpPerspectiveParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dst_width, uint16_t dst_height, float* transform_matrix, uint32_t border_value);
+
+    int setFastParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch, uint16_t threshold);
+
+    int setRemapParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dst_width, uint16_t dst_height, uint32_t border_color);
+
+    int setSrcImage(uint8_t *srcImgData);
+
+    int setMatchTempl(uint8_t *templData);
+
+    int setMapData(uint8_t *mapData);
+
+    int execDRP(void);
+
+    int readDstImage(uint8_t *dstImgData);
+
+    int readCornerPoints(std::vector<cv::KeyPoint> &keypoints);
+    int readTemplateMatchResult(uint8_t *dstImgData);
+
+    int get_drp_possiblef(uint16_t circuit_no);
+
+    int OCA_Activate(unsigned long* OCA_list);
+
+    void OCA_ConflictNotification(int oca_conflict);
+
+    void conflict_action_exec(void);
+
+    int set_drp_start();
+
+    int set_drp_end();
+
+private:
+    void dst_adr_64aligment(void);
+
+    void tmpl_adr_64aligment(void);
+
+    void map_adr_64aligment(void);
+
+    uint64_t opencv_bin_addr64_phy;     // physical memory area address (64bit)
+    
+    uint8_t opencv_bin_p[OCA_BIN_SIZE];      // opencva binary area(3.6M Byte = 400*1024*9 Byte)
+
+    bool initialized = false;           
+
+    void initialize(void);
+
+    static rzv2m_drp* _singleton;       // singleton object of drp
+
+private:
+    int fd_drp;
+    int fd_drv;
+
+    char *opencv_bin_signature_p = NULL;    // pointer to signature(16byte)
+    char *opencv_bin_version_p = NULL;      // pointer to version info(8byte)
+    uint32_t opencv_bin_list_base;          // opencva list address(offset value)
+    uint32_t opencv_bin_config_base;        // opencva circuit info address(offset value)
+    uint32_t opencv_bin_descriptor_base;    // opencva descriptor info address(offset value)
+    uint32_t opencv_bin_param_base;         // opencva parameter info address(offset value)
+
+    uint32_t possiblef;                 // existence flag of circuit data 
+    uint32_t drp_position;              // address at circuit data (offset value from CONFIG_BASE)
+    uint32_t drp_size;                  // circuit data size
+
+    uint64_t src_adr;   // physical address of src
+    uint64_t dst_adr;   // physical address of dst
+    uint64_t tmpl_adr;  // physical address of match template
+    uint64_t corner_adr;// physical address of detected corners
+    uint64_t map_adr;   // physical address of map
+
+    uint32_t src_size;
+    uint32_t dst_size;
+    uint32_t tmpl_size;
+    uint32_t map_size;
+    
+    drp_data_t proc[DRP_SEQ_NUM * 2];
+
+    uint32_t process_id = 0;
+    uint32_t thread_id = 0;
+};
+
+#endif
diff --git a/modules/imgproc/src/color.cpp b/modules/imgproc/src/color.cpp
index 4eaa051..9855342 100644
--- a/modules/imgproc/src/color.cpp
+++ b/modules/imgproc/src/color.cpp
@@ -6,6 +6,8 @@
 #include "opencl_kernels_imgproc.hpp"
 #include "color.hpp"
 
+#include <rzv2ma_drp.h>
+#include <opencv2/core/utils/logger.hpp>
 namespace cv
 {
 
@@ -181,6 +183,16 @@ void cvtColorTwoPlane( InputArray _ysrc, InputArray _uvsrc, OutputArray _dst, in
             return;
     }
 
+    _dst.create( _ysrc.rows(), _ysrc.cols(), CV_8UC3 );
+
+    int return_drp = 0;
+    return_drp = cvtColorTwoPlane_drp(_ysrc, _uvsrc, _dst, code);
+
+    if(DRP_NOT_EXECUTE != return_drp)
+    {
+        return;
+    }
+
     cvtColorTwoPlaneYUV2BGRpair(_ysrc, _uvsrc, _dst, dstChannels(code), swapBlue(code), uIndex(code));
 }
 
@@ -202,6 +214,9 @@ void cvtColor( InputArray _src, OutputArray _dst, int code, int dcn )
                 !(CV_MAT_DEPTH(_src.type()) == CV_8U && (code == COLOR_Luv2BGR || code == COLOR_Luv2RGB)),
                 ocl_cvtColor(_src, _dst, code, dcn) )
 
+    Mat mat_src = _src.getMat();
+    Mat mat_dst = _dst.getMat();
+
     switch( code )
     {
         case COLOR_BGR2BGRA: case COLOR_RGB2BGRA: case COLOR_BGRA2BGR:
@@ -321,8 +336,8 @@ void cvtColor( InputArray _src, OutputArray _dst, int code, int dcn )
         case COLOR_YUV2BGRA_NV21: case COLOR_YUV2RGBA_NV21: case COLOR_YUV2BGRA_NV12: case COLOR_YUV2RGBA_NV12:
             // http://www.fourcc.org/yuv.php#NV21 == yuv420sp -> a plane of 8 bit Y samples followed by an interleaved V/U plane containing 8 bit 2x2 subsampled chroma samples
             // http://www.fourcc.org/yuv.php#NV12 -> a plane of 8 bit Y samples followed by an interleaved U/V plane containing 8 bit 2x2 subsampled colour difference samples
-            cvtColorTwoPlaneYUV2BGR(_src, _dst, dcn, swapBlue(code), uIndex(code));
-            break;
+            cvtColorTwoPlaneYUV2BGR(_src, _dst, dcn, swapBlue(code), uIndex(code), code);
+	    break;
 
         case COLOR_YUV2BGR_YV12: case COLOR_YUV2RGB_YV12: case COLOR_YUV2BGRA_YV12: case COLOR_YUV2RGBA_YV12:
         case COLOR_YUV2BGR_IYUV: case COLOR_YUV2RGB_IYUV: case COLOR_YUV2BGRA_IYUV: case COLOR_YUV2RGBA_IYUV:
@@ -349,8 +364,8 @@ void cvtColor( InputArray _src, OutputArray _dst, int code, int dcn )
             {
                 int ycn  = (code==COLOR_YUV2RGB_UYVY || code==COLOR_YUV2BGR_UYVY ||
                             code==COLOR_YUV2RGBA_UYVY || code==COLOR_YUV2BGRA_UYVY) ? 1 : 0;
-                cvtColorOnePlaneYUV2BGR(_src, _dst, dcn, swapBlue(code), uIndex(code), ycn);
-                break;
+		cvtColorOnePlaneYUV2BGR(_src, _dst, dcn, swapBlue(code), uIndex(code), ycn, code);
+		break;
             }
 
         case COLOR_RGB2YUV_UYVY: case COLOR_BGR2YUV_UYVY: case COLOR_RGBA2YUV_UYVY: case COLOR_BGRA2YUV_UYVY:
@@ -362,6 +377,7 @@ void cvtColor( InputArray _src, OutputArray _dst, int code, int dcn )
             {
                 int ycn  = (code==COLOR_RGB2YUV_UYVY ||  code==COLOR_BGR2YUV_UYVY ||
                             code==COLOR_RGBA2YUV_UYVY || code==COLOR_BGRA2YUV_UYVY) ? 1 : 0;
+		CV_LOG_INFO(nullptr, "cvtColor continue to normal opencv.");
                 cvtColorOnePlaneBGR2YUV(_src, _dst, swapBlue(code), uIndex(code), ycn);
                 break;
             }
@@ -378,7 +394,57 @@ void cvtColor( InputArray _src, OutputArray _dst, int code, int dcn )
         case COLOR_mRGBA2RGBA:
             cvtColormRGBA2RGBA(_src, _dst);
             break;
-        default:
+        
+        /* drp opencva */
+        case COLOR_YUV_NV12_YUY2:
+            _dst.create( _src.rows() * 3 / 2, _src.cols(), CV_8UC1 );
+            mat_dst = _dst.getMat();
+            cvtYUVtoNV_drp(mat_src, mat_dst, 0, 0);
+            break;
+
+        case COLOR_YUV_NV12_YVYU:
+            _dst.create( _src.rows() * 3 / 2, _src.cols(), CV_8UC1 );
+            mat_dst = _dst.getMat();
+            cvtYUVtoNV_drp(mat_src, mat_dst, 1, 0);
+            break;
+
+        case COLOR_YUV_NV12_UYVY:
+            _dst.create( _src.rows() * 3 / 2, _src.cols(), CV_8UC1 );
+            mat_dst = _dst.getMat();
+            cvtYUVtoNV_drp(mat_src, mat_dst, 2, 0);
+            break;
+
+        case COLOR_YUV_NV12_VYUY:
+            _dst.create( _src.rows() * 3 / 2, _src.cols(), CV_8UC1 );
+            mat_dst = _dst.getMat();
+            cvtYUVtoNV_drp(mat_src, mat_dst, 3, 0);
+            break;
+
+        case COLOR_YUV_NV21_YUY2:
+            _dst.create( _src.rows() * 3 / 2, _src.cols(), CV_8UC1 );
+            mat_dst = _dst.getMat();
+            cvtYUVtoNV_drp(mat_src, mat_dst, 0, 1);
+            break;
+
+        case COLOR_YUV_NV21_YVYU:
+            _dst.create( _src.rows() * 3 / 2, _src.cols(), CV_8UC1 );
+            mat_dst = _dst.getMat();
+            cvtYUVtoNV_drp(mat_src, mat_dst, 1, 1);
+            break;
+
+        case COLOR_YUV_NV21_UYVY:
+            _dst.create( _src.rows() * 3 / 2, _src.cols(), CV_8UC1 );
+            mat_dst = _dst.getMat();
+            cvtYUVtoNV_drp(mat_src, mat_dst, 2, 1);
+            break;
+
+        case COLOR_YUV_NV21_VYUY:
+            _dst.create( _src.rows() * 3 / 2, _src.cols(), CV_8UC1 );
+            mat_dst = _dst.getMat();
+            cvtYUVtoNV_drp(mat_src, mat_dst, 3, 1);
+            break;
+	
+	default:
             CV_Error( CV_StsBadFlag, "Unknown/unsupported color conversion code" );
     }
 }
diff --git a/modules/imgproc/src/color.hpp b/modules/imgproc/src/color.hpp
index 6ebca26..0dc8a7e 100644
--- a/modules/imgproc/src/color.hpp
+++ b/modules/imgproc/src/color.hpp
@@ -559,6 +559,9 @@ void cvtColorXYZ2BGR( InputArray _src, OutputArray _dst, int dcn, bool swapb );
 void cvtColorBGR2YUV( InputArray _src, OutputArray _dst, bool swapb, bool crcb);
 void cvtColorYUV2BGR( InputArray _src, OutputArray _dst, int dcn, bool swapb, bool crcb);
 
+void cvtColorOnePlaneYUV2BGR( InputArray _src, OutputArray _dst, int dcn, bool swapb, int uidx, int ycn, int color_code);
+void cvtColorTwoPlaneYUV2BGR( InputArray _src, OutputArray _dst, int dcn, bool swapb, int uidx, int color_code);
+
 void cvtColorOnePlaneYUV2BGR( InputArray _src, OutputArray _dst, int dcn, bool swapb, int uidx, int ycn);
 void cvtColorOnePlaneBGR2YUV( InputArray _src, OutputArray _dst, bool swapb, int uidx, int ycn);
 void cvtColorTwoPlaneYUV2BGR( InputArray _src, OutputArray _dst, int dcn, bool swapb, int uidx );
@@ -583,4 +586,8 @@ void cvtColorGray25x5( InputArray _src, OutputArray _dst, int gbits);
 void cvtColorRGBA2mRGBA(InputArray _src, OutputArray _dst);
 void cvtColormRGBA2RGBA(InputArray _src, OutputArray _dst);
 
+int cvtYUVtoNV_drp(Mat src_mat, Mat dst_mat, int input_yuv, int output_nv);	
+int cvtYUVtoBGR_drp(Mat src_mat, Mat dst_mat, int width, int height, int color_code);
+int cvtColorTwoPlane_drp(InputArray _ysrc, InputArray _uvsrc, OutputArray _dst, int color_code);
+
 } //namespace cv
diff --git a/modules/imgproc/src/color_yuv.dispatch.cpp b/modules/imgproc/src/color_yuv.dispatch.cpp
index 73e1aea..ac6c6e1 100644
--- a/modules/imgproc/src/color_yuv.dispatch.cpp
+++ b/modules/imgproc/src/color_yuv.dispatch.cpp
@@ -10,8 +10,596 @@
 #include "color_yuv.simd.hpp"
 #include "color_yuv.simd_declarations.hpp" // defines CV_CPU_DISPATCH_MODES_ALL=AVX2,...,BASELINE based on CMakeLists.txt content
 
+#include <iostream>
+#include <rzv2ma_drp.h>
+#include <opencv2/core/utils/logger.hpp>
+
 namespace cv {
 
+/***********************************************************
+* Method Name   : cvtYUVtoNV_drp
+* Description   : to execute cvtYUVtoNV drp version
+* Arguments     : src_mat = input Mat object, dst_mat = output Mat object 
+*               : input_yuv = input yuv type, output_nv = output nv type 
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+************************************************************/
+int cvtYUVtoNV_drp(Mat src_mat, Mat dst_mat, int input_yuv, int output_nv)
+{
+    CV_LOG_INFO(nullptr, "cvtYUVtoNV_drp method start.");
+
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_YUV2NV);
+    
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    uint16_t dst_width = src_mat.cols;
+    uint16_t dst_height = src_mat.rows;
+   
+    /* dst image area */
+    uint8_t *out_image_buffer;
+
+    out_image_buffer = new uint8_t[dst_width * dst_height * 3 / 2];
+
+    int result = DRP_NORMAL_END;
+
+    /* Check src size */
+    if(3840 < src_mat.cols)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(2160 < src_mat.rows)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* checking input length even */
+    if(0 != src_mat.cols % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(0 != src_mat.rows % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* dst image size limit 4k */
+    if(3840*2160 < src_mat.cols*src_mat.rows)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if(2 != src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if(CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->setYUV2NVParameter(src_mat.cols, src_mat.rows, input_yuv, output_nv);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+ 
+    result = drp->setSrcImage(src_mat.data);
+
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->execDRP();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    out_image_buffer = new uint8_t[dst_width * dst_height * 3 / 2];
+
+    result = drp->readDstImage(out_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat dst_mat_out =  Mat(dst_height * 3 / 2, dst_width, CV_8UC1, out_image_buffer);    
+    dst_mat_out.copyTo(dst_mat);
+
+    drp->set_drp_end();
+
+    CV_LOG_INFO(nullptr, "cvtYUVtoNV_drp method end.");
+
+    return DRP_NORMAL_END;   
+}
+
+/***********************************************************
+* Method Name   : cvtYUVtoBGR_drp
+* Description   : to exec cvtYUVtoBGR drp version
+* Arguments     : src_mat = input Mat object, dst_mat = output Mat object 
+*               : width = input width, height = input height, color_code = color convert type 
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+************************************************************/
+int cvtYUVtoBGR_drp(Mat src_mat, Mat dst_mat, int width, int height, int color_code)
+{
+    CV_LOG_INFO(nullptr, "cvtYUVtoBGR_drp method start.");
+
+    /* can exec drp by color_code */
+    switch(color_code)
+    {
+        case COLOR_YUV2RGBA_UYVY: case COLOR_YUV2BGRA_UYVY:
+        case COLOR_YUV2RGBA_YUY2: case COLOR_YUV2BGRA_YUY2: case COLOR_YUV2RGBA_YVYU: case COLOR_YUV2BGRA_YVYU:
+
+        case COLOR_YUV2BGRA_NV21: case COLOR_YUV2RGBA_NV21: case COLOR_YUV2BGRA_NV12: case COLOR_YUV2RGBA_NV12:
+        
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_YUV2RGB);
+
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* continue to exec drp function */
+
+    /* dst image area */
+    uint8_t *out_image_buffer;
+
+    /* checking input length */
+    if(4 > width)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(3840 < width)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(6 > height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(2160 < height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(0 != src_mat.cols % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(0 != src_mat.rows % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if(CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if(2 != src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* size of dst image */
+    uint16_t dst_width = width;
+    uint16_t dst_height = height;
+    uint32_t input_size = dst_width * dst_height * 2;
+    int output_size = dst_width * dst_height * 3;
+
+    int result = DRP_NORMAL_END;
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* can exec drp by color_code */
+    int output_format_rgb = 0;
+    int input_format = 0x00;
+
+    switch(color_code)
+    {
+        case COLOR_YUV2RGB_YUY2:
+            input_format = 0;
+            break;
+
+        case COLOR_YUV2RGB_YVYU:
+            input_format = 1;
+            break;
+
+        case COLOR_YUV2RGB_UYVY:
+            input_format = 2;
+            break;
+
+        case COLOR_YUV2RGB_VYUY:
+            input_format = 3;
+            break;
+        
+        case COLOR_YUV2BGR_YUY2:
+            input_format = 0;
+            output_format_rgb = 1;
+            break;
+
+        case COLOR_YUV2BGR_YVYU:
+            input_format = 1;
+            output_format_rgb = 1;
+            break;
+
+        case COLOR_YUV2BGR_UYVY:
+            input_format = 2;
+            output_format_rgb = 1;
+            break;
+
+        case COLOR_YUV2BGR_VYUY:
+            input_format = 3;
+            output_format_rgb = 1;
+            break;
+
+        case COLOR_YUV2RGB_NV21:
+            input_format = 0x1005;
+            input_size = dst_width * dst_height * 3 / 2; 
+            output_size = dst_width * dst_height * 3;
+            output_format_rgb = 0;
+            break;
+
+        case COLOR_YUV2BGR_NV21:
+            input_format = 0x1005;
+            input_size = dst_width * dst_height * 3 / 2; 
+            output_size = dst_width * dst_height * 3;
+            output_format_rgb = 1;
+            break;
+        
+        case COLOR_YUV2RGB_NV12:
+            input_format = 0x1004;
+            input_size = dst_width * dst_height * 3 / 2; 
+            output_size = dst_width * dst_height * 3;
+            output_format_rgb = 0;
+            break;
+          
+        case COLOR_YUV2BGR_NV12:
+            input_format = 0x1004;
+            input_size = dst_width * dst_height * 3 / 2; 
+            output_size = dst_width * dst_height * 3;
+            output_format_rgb = 1;
+            break;  
+    }
+
+    result = drp->setYUV2RGBParameter(width, height, input_size, input_format, dst_width, dst_height, output_format_rgb);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+ 
+    result = drp->setSrcImage(src_mat.data);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->execDRP();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    out_image_buffer = new uint8_t[output_size];
+
+    result = drp->readDstImage(out_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat dst_mat_out = Mat(dst_height, dst_width, CV_8UC3, out_image_buffer);
+    dst_mat_out.copyTo(dst_mat);
+
+    CV_LOG_INFO(nullptr, "cvtYUVtoBGR_drp method end.");
+
+    drp->set_drp_end();
+
+    return DRP_NORMAL_END;
+}
+
+/***********************************************************
+* Method Name   : cvtColorTwoPlane_drp
+* Description   : to execute cvtColorTwoPlane_drp
+* Arguments     : _ysrc = input y data, _uvsrc = input uv data
+*               : _dst = output Mat, color_code = color convert type 
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+************************************************************/
+int cvtColorTwoPlane_drp(InputArray _ysrc, InputArray _uvsrc, OutputArray _dst, int color_code)
+{
+    /* can exec drp by color_code */
+    switch(color_code)
+    {
+        case COLOR_YUV2BGRA_NV21: case COLOR_YUV2RGBA_NV21: case COLOR_YUV2BGRA_NV12: case COLOR_YUV2RGBA_NV12:
+
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_YUV2RGB);
+
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    CV_LOG_INFO(nullptr, "cvtColorTwoPlane_drp method start.");
+
+    Mat ysrc = _ysrc.getMat();
+    Mat uvsrc = _uvsrc.getMat();
+    Mat dst_mat = _dst.getMat();
+
+    uint16_t src1_width = ysrc.cols;
+    uint16_t src1_height = ysrc.rows;
+    uint16_t src2_width = uvsrc.cols;
+    uint16_t src2_height = uvsrc.rows;
+    uint16_t dst_width = src1_width;
+    uint16_t dst_height = src1_height;
+
+    uint8_t *input_image_buffer;
+    uint8_t *out_image_buffer; 
+    uint32_t input_size = 0;
+    uint32_t output_size = 0;
+    
+    input_size = src1_width * src1_height;
+    input_size += src1_width * src1_height / 2;
+    
+    input_image_buffer = new uint8_t[input_size];
+
+    /* checking input length */
+    if(4 > src1_width)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(3840 < src1_width)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(6 > src1_height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(2160 < src1_height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(0 != src1_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(0 != src1_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if(CV_8U != ysrc.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if(1 != ysrc.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* checking input length */
+    if(src1_width / 2 != src2_width)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(src1_height / 2 != src2_height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if(2 != uvsrc.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if(CV_8U != ysrc.depth() || CV_8U != uvsrc.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    int result = DRP_NORMAL_END;
+
+    /* check continuous */
+    if(!ysrc.isContinuous())
+    {
+        ysrc = ysrc.clone();
+    }
+    if(!uvsrc.isContinuous())
+    {
+        uvsrc = uvsrc.clone();
+    }
+    
+    memcpy(input_image_buffer, ysrc.data, src1_width * src1_height);    
+    memcpy(input_image_buffer + (src1_width * src1_height), uvsrc.data, src1_width * src1_height / 2);
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* can exec drp by color_code */
+    int output_format_rgb = 0;
+    int input_format = 0x00;
+
+    output_size = dst_width * dst_height * 3;
+
+    switch(color_code)
+    {
+        case COLOR_YUV2RGB_NV21:
+            input_format = 0x1005;
+            output_format_rgb = 0;
+            break;
+
+        case COLOR_YUV2BGR_NV21:
+            input_format = 0x1005;
+            output_format_rgb = 1;
+            break;
+        
+        case COLOR_YUV2RGB_NV12:
+            input_format = 0x1004;
+            output_format_rgb = 0;
+            break;
+
+        case COLOR_YUV2BGR_NV12:
+            input_format = 0x1004;
+            output_format_rgb = 1;
+            break;
+    }
+
+    result = drp->setYUV2RGBParameter(src1_width, src1_height, input_size, input_format, dst_width, dst_height, output_format_rgb);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+ 
+    result = drp->setSrcImage(input_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->execDRP();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    out_image_buffer = new uint8_t[output_size];
+
+    result = drp->readDstImage(out_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat dst_mat_out = Mat(dst_height, dst_width, CV_8UC3, out_image_buffer);
+    dst_mat_out.copyTo(dst_mat);
+
+    delete[] input_image_buffer;
+
+    drp->set_drp_end();
+
+    CV_LOG_INFO(nullptr, "cvtColorTwoPlane_drp method end.");
+
+    return DRP_NORMAL_END;
+}
+
 //
 // HAL functions
 //
@@ -379,8 +967,25 @@ void cvtColorYUV2BGR(InputArray _src, OutputArray _dst, int dcn, bool swapb, boo
                      h.depth, dcn, swapb, crcb);
 }
 
-void cvtColorOnePlaneYUV2BGR( InputArray _src, OutputArray _dst, int dcn, bool swapb, int uidx, int ycn)
+void cvtColorOnePlaneYUV2BGR( InputArray _src, OutputArray _dst, int dcn, bool swapb, int uidx, int ycn, int color_code)
 {
+    CV_LOG_INFO(nullptr, "cvtColorOnePlaneYUV2BGR start.");
+
+    _dst.create( _src.size(), CV_8UC3 );
+    Mat src = _src.getMat();
+    Mat dst = _dst.getMat();
+
+    /* First, to call drp process */
+    int return_drp = 0;
+
+    return_drp = cv::cvtYUVtoBGR_drp(src, dst, src.cols, src.rows, color_code);
+    if(DRP_NOT_EXECUTE != return_drp)
+    {
+        return;
+    }
+
+    CV_LOG_INFO(nullptr, "exec cvtColorOnePlaneYUV2BGR normal OpenCV.");
+
     CvtHelper< Set<2>, Set<3, 4>, Set<CV_8U>, FROM_UYVY > h(_src, _dst, dcn);
 
     hal::cvtOnePlaneYUVtoBGR(h.src.data, h.src.step, h.dst.data, h.dst.step, h.src.cols, h.src.rows,
@@ -436,8 +1041,25 @@ void cvtColorThreePlaneYUV2BGR( InputArray _src, OutputArray _dst, int dcn, bool
 // http://www.fourcc.org/yuv.php#NV21 == yuv420sp -> a plane of 8 bit Y samples followed by an interleaved V/U plane containing 8 bit 2x2 subsampled chroma samples
 // http://www.fourcc.org/yuv.php#NV12 -> a plane of 8 bit Y samples followed by an interleaved U/V plane containing 8 bit 2x2 subsampled colour difference samples
 
-void cvtColorTwoPlaneYUV2BGR( InputArray _src, OutputArray _dst, int dcn, bool swapb, int uidx )
+void cvtColorTwoPlaneYUV2BGR(InputArray _src, OutputArray _dst, int dcn, bool swapb, int uidx, int color_code)
 {
+    CV_LOG_INFO(nullptr, "cvtColorTwoPlaneYUV2BGR start."); 
+
+   _dst.create( _src.size(), CV_8UC3 );
+    Mat src = _src.getMat();
+    Mat dst = _dst.getMat();
+
+    /* First, to call drp process */ 
+    int return_drp = 0;
+
+    return_drp = cv::cvtYUVtoBGR_drp(src, dst, src.cols, src.rows, color_code);
+    if(DRP_NOT_EXECUTE != return_drp)
+    {
+        return;
+    }
+
+    CV_LOG_INFO(nullptr, "exec cvtColorTwoPlaneYUV2BGR OpenCV normal."); 
+
     if(dcn <= 0) dcn = 3;
     CvtHelper< Set<1>, Set<3, 4>, Set<CV_8U>, FROM_YUV> h(_src, _dst, dcn);
 
diff --git a/modules/imgproc/src/deriv.cpp b/modules/imgproc/src/deriv.cpp
index 9cec64a..4d3a3b9 100644
--- a/modules/imgproc/src/deriv.cpp
+++ b/modules/imgproc/src/deriv.cpp
@@ -46,6 +46,9 @@
 #include "opencv2/core/openvx/ovx_defs.hpp"
 #include "filter.hpp"
 
+#include <opencv2/core/utils/logger.hpp>
+#include <rzv2ma_drp.h>
+
 /****************************************************************************************\
                              Sobel & Scharr Derivative Filters
 \****************************************************************************************/
@@ -411,11 +414,195 @@ static bool ocl_sepFilter3x3_8UC1(InputArray _src, OutputArray _dst, int ddepth,
 }
 #endif
 
+/***********************************************************************
+* Method Name   : cv::Sobel_drp
+* Description   : to execute cv::Sobel_drp
+*               : _src = input image object, _dst = output image object
+*               : ddepth = output image depth, dx = order of the drivative x
+*               : dy = order of the drivative y, ksize = (option) kernal size
+*               : scale = (option)scale factor, delta = (option) delta value 
+*               : borderType = (option)border type,
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+************************************************************************/
+int cv::Sobel_drp(InputArray _src, OutputArray _dst, int ddepth, int dx, int dy,
+                int ksize, double scale, double delta, int borderType)
+{
+    /* exec drp function process */
+    CV_LOG_INFO(nullptr, "Sobel_drp start.");
+
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_SOBEL);
+    
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* convert to mat object */
+    Mat src_mat = _src.getMat();
+
+    /* first, check can exec drp circuit */
+    uint32_t src_width = src_mat.cols;
+    uint32_t src_height = src_mat.rows;
+    uint32_t dst_width = src_width;
+    uint32_t dst_height = src_height;
+    uint16_t src_ch = src_mat.channels();
+    uint8_t *out_image_buffer;
+
+    Mat dst_mat = _dst.getMat();
+
+    int result = DRP_NORMAL_END;
+
+    /* width */
+    if (3840 < src_width || 16 > src_width || 0 != src_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* height */
+    if (2160 < src_height || 16 > src_height || 0 != src_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if (1 > src_mat.channels() || 4 < src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if (CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* dx dy (dx=1 and dy=0) or (dx=0 and dy=1) */
+    if ( !(1 == dx && 0 == dy) && !(0 == dx && 1 == dy) )
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* ksize = 3 */
+    if( 3 != ksize )
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* scale = 1 */
+    if( 1 != scale )
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* delta = 0 */
+    if( 0 != delta )
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* ddepth = -1 */
+    if( -1 != ddepth )
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* borderType = BORDER_DEFAULT */
+    if(BORDER_DEFAULT != borderType)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* set dx, dy parameter */
+    uint16_t deltaXY = 99;
+    if(dx == 1 && dy == 0)
+    {
+        deltaXY = 0;
+    }
+    else if(dx == 0 && dy == 1)
+    {
+        deltaXY = 1;
+    }
+
+    result = drp->setSobelParameter(src_width, src_height, src_ch, deltaXY);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->setSrcImage(src_mat.data);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->execDRP();
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    out_image_buffer = new uint8_t[src_width * src_height * src_ch];
+
+    result = drp->readDstImage(out_image_buffer);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;       
+    }
+    
+    Mat dst_mat_out = Mat(dst_height, dst_width, CV_MAKETYPE(src_mat.depth(), src_ch), out_image_buffer);
+    dst_mat_out.copyTo(_dst);
+
+    delete[] out_image_buffer;
+
+    CV_LOG_INFO(nullptr, "Sobel_drp end.");
+
+    drp->set_drp_end();
+
+    return result;
+}
+
 void cv::Sobel( InputArray _src, OutputArray _dst, int ddepth, int dx, int dy,
                 int ksize, double scale, double delta, int borderType )
 {
     CV_INSTRUMENT_REGION();
 
+    /* ddepth to drp */
+    int ddepth_drp = ddepth;    
+
     CV_Assert(!_src.empty());
 
     int stype = _src.type(), sdepth = CV_MAT_DEPTH(stype), cn = CV_MAT_CN(stype);
@@ -448,6 +635,15 @@ void cv::Sobel( InputArray _src, OutputArray _dst, int ddepth, int dx, int dy,
     Mat src = _src.getMat();
     Mat dst = _dst.getMat();
 
+    /* exec Sobel_drp */
+    int result = Sobel_drp(_src, _dst, ddepth_drp, dx, dy, ksize, scale, delta, borderType);
+    if(DRP_NOT_EXECUTE != result)
+    {
+        return;
+    }
+
+    CV_LOG_INFO(nullptr, "continue to normal opencv.");
+
     Point ofs;
     Size wsz(src.cols, src.rows);
     if(!(borderType & BORDER_ISOLATED))
diff --git a/modules/imgproc/src/filter.dispatch.cpp b/modules/imgproc/src/filter.dispatch.cpp
index b5acbc8..500a14a 100644
--- a/modules/imgproc/src/filter.dispatch.cpp
+++ b/modules/imgproc/src/filter.dispatch.cpp
@@ -56,7 +56,8 @@
 #include "filter.simd.hpp"
 #include "filter.simd_declarations.hpp" // defines CV_CPU_DISPATCH_MODES_ALL=AVX2,...,BASELINE based on CMakeLists.txt content
 
-
+#include <rzv2ma_drp.h>
+#include <opencv2/core/utils/logger.hpp>
 /****************************************************************************************\
                                     Base Image Filter
 \****************************************************************************************/
@@ -1518,11 +1519,220 @@ void sepFilter2D(int stype, int dtype, int ktype,
 //================================================================
 //   Main interface
 //================================================================
+/***********************************************************
+* Method Name   : filter2D_drp
+* Description   : to execute filter2D_drp
+*               : _src = input image object, _dst = output image object
+*               : _kernel = kernel object,  anchor0 = position of the anchor
+*               : delta(option filtered pixel), borderType = border type,
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+************************************************************/
+int filter2D_drp(InputArray _src, OutputArray _dst, int ddepth,
+              InputArray _kernel, Point anchor0,
+              double delta, int borderType)
+{
+    CV_LOG_INFO(nullptr, "filter2d_drp start(with ocl support check.) ");
+
+    /* exec drp function process */
+
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_FILTER2D);
+    
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* convert to mat object */
+    Mat src_mat = _src.getMat();
+    Mat kernel_mat = _kernel.getMat();
+
+    /* first, check can exec drp circuit */
+    uint32_t src_width = src_mat.cols;
+    uint32_t src_height = src_mat.rows;
+    uint32_t dst_width = src_width;
+    uint32_t dst_height = src_height;
+    uint16_t src_ch = src_mat.channels();
+    uint8_t *out_image_buffer;
+
+    /* width */
+    if (3840 < src_width || 16 > src_width || 0 != src_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* height */
+    if (2160 < src_height || 16 > src_height || 0 != src_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if (1 > src_mat.channels() || 4 < src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if (CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* borderType */
+    if (borderType != BORDER_DEFAULT)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* ddepth (-1) means same as src depth */
+    if (ddepth != -1)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* anchor0: default value(-1,-1) only. (from specification) */
+    /* anchor0 x */
+    if(anchor0.x != -1)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* anchor0 y */
+    if(anchor0.y != -1)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* delta */
+    if(delta != 0)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* kernel width */
+    if(kernel_mat.cols != 3)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* kernel height */
+    if(kernel_mat.rows != 3)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* kernel depth */
+    if (CV_32F != kernel_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+    
+    /* kernel to simple array */
+    float filterVals[9];
+    int idxfilter = 0;
+
+    for(int j = 0; j < kernel_mat.cols; j++)
+    {
+        for(int i = 0; i < kernel_mat.rows; i++)
+        {
+            filterVals[idxfilter] = kernel_mat.at<float>(j,i);
+            idxfilter++;
+        }
+    }
+
+    /* range check */
+    for(idxfilter = 0; idxfilter < 9; idxfilter++)
+    {
+        if(filterVals[idxfilter] <= -128 || filterVals[idxfilter] > 127)
+        {
+            return DRP_NOT_EXECUTE;
+        }
+    }
+
+    Mat dst_mat = _dst.getMat();
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    int result = DRP_NORMAL_END;
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->setFilter2dParameter(src_width, src_height, src_ch, filterVals);
+
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->setSrcImage(src_mat.data);
+
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->execDRP();
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    out_image_buffer = new uint8_t[src_width * src_height * src_ch];
+
+    result = drp->readDstImage(out_image_buffer);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;       
+    }
+    
+    Mat dst_mat_out = Mat(dst_height, dst_width, CV_MAKETYPE(src_mat.depth(), src_ch), out_image_buffer);
+    dst_mat_out.copyTo(_dst);
+
+    delete[] out_image_buffer;
+
+    CV_LOG_INFO(nullptr, "Filter2d_drp end.");
+
+    drp->set_drp_end();
+
+    return result;
+}
 
 void filter2D(InputArray _src, OutputArray _dst, int ddepth,
               InputArray _kernel, Point anchor0,
               double delta, int borderType)
 {
+    int ddeptharg = ddepth;  //ddepth to drp function
+
     CV_INSTRUMENT_REGION();
 
     CV_Assert(!_src.empty());
@@ -1545,6 +1755,17 @@ void filter2D(InputArray _src, OutputArray _dst, int ddepth,
     if( (borderType & BORDER_ISOLATED) == 0 )
         src.locateROI( wsz, ofs );
 
+    /* next, exec drp function */
+    int ret = filter2D_drp(_src, _dst, ddeptharg, _kernel, anchor0, delta, borderType);
+    if(ret != DRP_NOT_EXECUTE)
+    {
+        CV_LOG_INFO(nullptr, "Filter2d_drp nornal end.");
+        return;
+    }
+
+    /* if drp function not executed, contine to normal opencv function */
+    CV_LOG_INFO(nullptr, "continue to nornal opencv procedure.");
+
     hal::filter2D(src.type(), dst.type(), kernel.type(),
                   src.data, src.step, dst.data, dst.step,
                   dst.cols, dst.rows, wsz.width, wsz.height, ofs.x, ofs.y,
diff --git a/modules/imgproc/src/imgwarp.cpp b/modules/imgproc/src/imgwarp.cpp
index 39f983a..9b109e7 100644
--- a/modules/imgproc/src/imgwarp.cpp
+++ b/modules/imgproc/src/imgwarp.cpp
@@ -56,6 +56,9 @@
 #include "opencv2/core/softfloat.hpp"
 #include "imgwarp.hpp"
 
+#include <rzv2ma_drp.h>
+#include <opencv2/core/utils/logger.hpp>
+
 using namespace cv;
 
 namespace cv
@@ -1680,6 +1683,205 @@ private:
 #endif
 
 }
+int cv::remap_drp(InputArray _src, OutputArray _dst,
+              InputArray _map1, InputArray _map2,
+              int interpolation, int borderMode, const Scalar& borderValue)
+{
+    CV_LOG_INFO(nullptr, "remap_drp start.");
+
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        CV_LOG_INFO(nullptr, "remap_drp get instance");
+        return DRP_NOT_EXECUTE;
+    }
+
+    int result = DRP_NORMAL_END;
+
+    /* get possible flag */
+    int remap_possiblef = drp->get_drp_possiblef(PARAM_NO_REMAP);
+
+    /* active status only */
+    if(remap_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to convert to Mat class */
+    Mat src_mat = _src.getMat();
+    Mat map_mat = _map1.getMat();
+
+    /* to set remap spec */
+    uint32_t src_width = src_mat.size().width;
+    uint32_t src_height = src_mat.size().height;
+    uint32_t src_ch = src_mat.channels();
+    int src_depth = src_mat.depth();
+
+    uint32_t map_width = map_mat.size().width;
+    uint32_t map_height = map_mat.size().height;
+    int map_depth = map_mat.depth();
+
+    /* checking src width */
+    if(3840 < src_width || 16 > src_width || 0 != src_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* checking src height */
+    if(2160 < src_height || 16 > src_height || 0 != src_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* checking src channel size */
+    if((1 > src_ch) || (4 < src_ch))
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* checking src depth */
+    if(CV_8U != src_depth)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* checking map1 width */
+    if(3840 < map_width || 16 > map_width || 0 != map_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* checking map1 height */
+    if(2160 < map_height || 16 > map_height || 0 != map_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* checking map1 depth */
+    if(CV_32F != map_depth)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* checking map2 isn't empty */
+    if(!_map2.empty())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* checking interpolation */
+    if(interpolation != INTER_LINEAR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* checking borderMode */
+    if(borderMode != BORDER_CONSTANT)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* dst src size */
+    uint32_t dst_width = map_width;
+    uint32_t dst_height = map_height;
+    uint16_t dst_ch = src_ch;
+
+    /* output image buffer */
+    uint8_t *out_image_buffer;
+
+    /* border value */
+    uint32_t border_value_32t = 0;
+    uint8_t bgra_8t[4];
+
+    bgra_8t[0] = borderValue(0); //B
+    bgra_8t[1] = borderValue(1); //G
+    bgra_8t[2] = borderValue(2); //R
+    bgra_8t[3] = borderValue(3); //A
+
+    memcpy(&border_value_32t, bgra_8t, 4);
+
+    out_image_buffer = new uint8_t[dst_width*dst_height*dst_ch];
+
+    /* check continuous src */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    /* check continuous map */
+    if(!map_mat.isContinuous())
+    {
+        map_mat = map_mat.clone();
+    }
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        CV_LOG_INFO(nullptr, "rmap_drp read header error.");
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set remap parameter */
+    result = drp->setRemapParameter(src_width, src_height, src_ch, dst_width, dst_height, border_value_32t);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set remap src image to drp input area */
+    result = drp->setSrcImage(src_mat.data);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set remap map data to drp input area */
+    result = drp->setMapData(map_mat.data);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* executing drp process */
+    result = drp->execDRP();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to read warpPerspective dst image from drp output area */
+    result = drp->readDstImage(out_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to convert mat object */
+    Mat dst_mat_out =  Mat(dst_height, dst_width, CV_8UC(dst_ch), out_image_buffer);
+    dst_mat_out.copyTo(_dst);
+
+    delete[] out_image_buffer;
+
+    drp->set_drp_end();
+
+    CV_LOG_INFO(nullptr, "remap_drp end.");
+
+    return DRP_NORMAL_END;
+}
 
 void cv::remap( InputArray _src, OutputArray _dst,
                 InputArray _map1, InputArray _map2,
@@ -1743,6 +1945,14 @@ void cv::remap( InputArray _src, OutputArray _dst,
 
     CV_Assert( dst.cols < SHRT_MAX && dst.rows < SHRT_MAX && src.cols < SHRT_MAX && src.rows < SHRT_MAX );
 
+    int result = cv::remap_drp(_src, _dst, _map1, _map2, interpolation, borderType, borderValue);
+    if(result == DRP_NORMAL_END)
+    {
+        return;
+    }
+
+    CV_LOG_INFO(nullptr, "remap_drp continue to normal opencv.");
+
     if( dst.data == src.data )
         src = src.clone();
 
@@ -2722,6 +2932,201 @@ void warpAffine(int src_type,
 } // hal::
 } // cv::
 
+/*****************************************
+* Method Name   : warpAffline_drp
+* Description   : to exec drp process of OpenCV accelerator warpAffine.
+* Arguments     : _src = src image(Mat), _dst = dst image(Mat), _M0 = tranceformation,
+                dsize = output size, flags = combination of interpolation,
+                borderType = pixel extrapolation method, borderValue = in case of a constant border
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+******************************************/
+int cv::warpAffine_drp(InputArray _src, OutputArray _dst,
+                     InputArray _M0, Size dsize,
+                     int flags, int borderMode, const Scalar& borderValue)
+{
+    CV_LOG_INFO(nullptr, "warpAffine_drp start.");
+  
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        CV_LOG_INFO(nullptr, "warpAffine_drp get instance");
+        return DRP_NOT_EXECUTE;
+    }
+
+    int result = DRP_NORMAL_END;
+
+    /* output image buffer */
+    uint8_t *out_image_buffer;
+
+    /* get possible flag */
+    int affine_possiblef = drp->get_drp_possiblef(PARAM_NO_WARPAFFINE);
+    
+    /* active status only */
+    if(affine_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat src_mat = _src.getMat();
+    Mat dst_mat = _dst.getMat();
+
+    /* set width height ch */
+    uint16_t src_width = src_mat.size().width;
+    uint16_t src_height = src_mat.size().height;
+    uint16_t dst_width = dst_mat.size().width;
+    uint16_t dst_height = dst_mat.size().height;
+    uint16_t src_ch = src_mat.channels();
+    uint16_t dst_ch = dst_mat.channels();
+
+    /* src width */
+    if(3840 < src_width || 16 > src_width || 0 != src_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* src height */
+    if(2160 < src_height || 16 > src_height || 0 != src_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if(1 > src_mat.channels() || 4 < src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if(CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* output width */
+    if(3840 < dsize.width || 16 > dsize.width || 0 != dsize.width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* output height */
+    if(2160 < dsize.height || 16 > dsize.height || 0 != dsize.height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat M0_mat = _M0.getMat();
+    if(M0_mat.depth() != CV_32F)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* transform matrix */
+    if(M0_mat.cols != 3 || M0_mat.rows != 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* flags */
+    if(flags != INTER_LINEAR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* borderMode */
+    if(borderMode != BORDER_CONSTANT)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* border value */
+    uint32_t border_value_32t = 0;
+    uint8_t bgra_8t[4];
+
+    bgra_8t[0] = borderValue(0); //B
+    bgra_8t[1] = borderValue(1); //G
+    bgra_8t[2] = borderValue(2); //R
+    bgra_8t[3] = borderValue(3); //A
+    
+    memcpy(&border_value_32t, bgra_8t, 4);
+
+    /* set transformation matrix */
+    float f_M0[6];
+    f_M0[0] = M0_mat.at<float>(0,0);
+    f_M0[1] = M0_mat.at<float>(0,1);
+    f_M0[2] = M0_mat.at<float>(0,2);
+    f_M0[3] = M0_mat.at<float>(1,0);
+    f_M0[4] = M0_mat.at<float>(1,1);
+    f_M0[5] = M0_mat.at<float>(1,2);
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+    
+    out_image_buffer = new uint8_t[dst_width*dst_height*dst_ch];
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+ 
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        CV_LOG_INFO(nullptr, "warpAffine_drp read header error.");
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+    
+    /* to set warpAffine parameter */
+    result = drp->setWarpAffineParameter(src_width, src_height, src_ch, dst_width, dst_height, f_M0, border_value_32t);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set warpAffine src image to drp input area */
+    result = drp->setSrcImage(src_mat.data);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* executing drp process */
+    result = drp->execDRP();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to read warpAffine dst image from drp output area */
+    result = drp->readDstImage(out_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to convert mat object */
+    Mat dst_mat_out =  Mat(dst_height, dst_width, CV_8UC(dst_ch), out_image_buffer);
+    dst_mat_out.copyTo(_dst);
+
+    delete[] out_image_buffer;
+
+    drp->set_drp_end();
+
+    CV_LOG_INFO(nullptr, "warpAffine_drp end.");
+
+    return DRP_NORMAL_END;
+}
 
 void cv::warpAffine( InputArray _src, OutputArray _dst,
                      InputArray _M0, Size dsize,
@@ -2835,6 +3240,14 @@ void cv::warpAffine( InputArray _src, OutputArray _dst,
     }
 #endif
 
+    int result = cv::warpAffine_drp(_src, _dst, _M0, dsize, flags, borderType, borderValue);
+    if(result == DRP_NORMAL_END)
+    {
+        return;
+    }
+
+    CV_LOG_INFO(nullptr, "warpAffine_drp continue to normal opencv.");
+
     hal::warpAffine(src.type(), src.data, src.step, src.cols, src.rows, dst.data, dst.step, dst.cols, dst.rows,
                     M, interpolation, borderType, borderValue.val);
 }
@@ -3291,6 +3704,204 @@ void warpPerspective(int src_type,
 } // hal::
 } // cv::
 
+/*****************************************
+* Method Name   : warpPerspective_drp
+* Description   : to exec drp process of OpenCV accelerator warpPerspective.
+* Arguments     : _src = src image(Mat), _dst = dst image(Mat), _M0 = tranceformation,
+                dsize = output size, flags = combination of interpolation,
+                borderMode = pixel extrapolation method, borderValue = in case of a constant border
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+******************************************/
+int cv::warpPerspective_drp( InputArray _src, OutputArray _dst, InputArray _M0,
+                          Size dsize, int flags, int borderMode, const Scalar& borderValue )
+{
+    CV_LOG_INFO(nullptr, "warpPerspective_drp start.");
+  
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        CV_LOG_INFO(nullptr, "warpPerspective_drp get instance");
+        return DRP_NOT_EXECUTE;
+    }
+
+    int result = DRP_NORMAL_END;
+
+    /* output image buffer */
+    uint8_t *out_image_buffer;
+
+    /* get possible flag */
+    int perspective_possiblef = drp->get_drp_possiblef(PARAM_NO_WARPPERSPECTIVE);
+    
+    /* active status only */
+    if(perspective_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat src_mat = _src.getMat();
+    Mat dst_mat = _dst.getMat();
+
+    /* set width height ch */
+    uint16_t src_width = src_mat.size().width;
+    uint16_t src_height = src_mat.size().height;
+    uint16_t dst_width = dst_mat.size().width;
+    uint16_t dst_height = dst_mat.size().height;
+    uint16_t src_ch = src_mat.channels();
+    uint16_t dst_ch = dst_mat.channels();
+
+    /* src width */
+    if(3840 < src_width || 16 > src_width || 0 != src_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* src height */
+    if(2160 < src_height || 16 > src_height || 0 != src_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if(1 > src_mat.channels() || 4 < src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if(CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* output width */
+    if(3840 < dsize.width || 16 > dsize.width || 0 != dsize.width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* output height */
+    if(2160 < dsize.height || 16 > dsize.height || 0 != dsize.height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat M0_mat = _M0.getMat();
+    if(M0_mat.depth() != CV_32F)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* transform matrix */
+    if(M0_mat.cols != 3 || M0_mat.rows != 3)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* flags */
+    if(flags != INTER_LINEAR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* borderMode */
+    if(borderMode != BORDER_CONSTANT)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* border value */
+    uint32_t border_value_32t = 0;
+    uint8_t bgra_8t[4];
+
+    bgra_8t[0] = borderValue(0); //B
+    bgra_8t[1] = borderValue(1); //G
+    bgra_8t[2] = borderValue(2); //R
+    bgra_8t[3] = borderValue(3); //A
+    
+    memcpy(&border_value_32t, bgra_8t, 4);
+
+    /* set transformation matrix */
+    float f_M0[9];
+    f_M0[0] = M0_mat.at<float>(0,0);
+    f_M0[1] = M0_mat.at<float>(0,1);
+    f_M0[2] = M0_mat.at<float>(0,2);
+    f_M0[3] = M0_mat.at<float>(1,0);
+    f_M0[4] = M0_mat.at<float>(1,1);
+    f_M0[5] = M0_mat.at<float>(1,2);
+    f_M0[6] = M0_mat.at<float>(2,0);
+    f_M0[7] = M0_mat.at<float>(2,1);
+    f_M0[8] = M0_mat.at<float>(2,2);
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    out_image_buffer = new uint8_t[dst_width*dst_height*dst_ch];
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+ 
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        CV_LOG_INFO(nullptr, "warpPerspective_drp read header error.");
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+    
+    /* to set warpPerspective parameter */
+    result = drp->setWarpPerspectiveParameter(src_width, src_height, src_ch, dst_width, dst_height, f_M0, border_value_32t);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set warpPerspective src image to drp input area */
+    result = drp->setSrcImage(src_mat.data);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* executing drp process */
+    result = drp->execDRP();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to read warpPerspective dst image from drp output area */
+    result = drp->readDstImage(out_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to convert mat object */
+    Mat dst_mat_out =  Mat(dst_height, dst_width, CV_8UC(dst_ch), out_image_buffer);
+    dst_mat_out.copyTo(_dst);
+
+    delete[] out_image_buffer;
+
+    drp->set_drp_end();
+
+    CV_LOG_INFO(nullptr, "warpPerspective_drp end.");
+
+    return DRP_NORMAL_END;
+}
+
 void cv::warpPerspective( InputArray _src, OutputArray _dst, InputArray _M0,
                           Size dsize, int flags, int borderType, const Scalar& borderValue )
 {
@@ -3385,6 +3996,14 @@ void cv::warpPerspective( InputArray _src, OutputArray _dst, InputArray _M0,
     if( !(flags & WARP_INVERSE_MAP) )
         invert(matM, matM);
 
+    int result = cv::warpPerspective_drp(_src, _dst, _M0, dsize, flags, borderType, borderValue);
+    if(result == DRP_NORMAL_END)
+    {
+        return;
+    }
+
+    CV_LOG_INFO(nullptr, "warpPerspective_drp continue to normal opencv.");
+
     hal::warpPerspective(src.type(), src.data, src.step, src.cols, src.rows, dst.data, dst.step, dst.cols, dst.rows,
                         matM.ptr<double>(), interpolation, borderType, borderValue.val);
 }
diff --git a/modules/imgproc/src/morph.dispatch.cpp b/modules/imgproc/src/morph.dispatch.cpp
index a0857d1..6c03ae2 100644
--- a/modules/imgproc/src/morph.dispatch.cpp
+++ b/modules/imgproc/src/morph.dispatch.cpp
@@ -51,6 +51,8 @@
 #include "morph.simd.hpp"
 #include "morph.simd_declarations.hpp" // defines CV_CPU_DISPATCH_MODES_ALL=AVX2,...,BASELINE based on CMakeLists.txt content
 
+#include <rzv2ma_drp.h>
+#include <opencv2/core/utils/logger.hpp>
 
 /****************************************************************************************\
                      Basic Morphological Operations: Erosion & Dilation
@@ -1001,6 +1003,215 @@ static void morphOp( int op, InputArray _src, OutputArray _dst,
                (src.isSubmatrix() && !isolated));
 }
 
+/***********************************************************
+* Method Name   : morphOp_drp
+* Description   : to execute morphOp_drp
+* Arguments     : op = operation(MORPH_DILATE or MORPH_ERODE)
+*               : _src = input image object, _dst = output image object
+*               : _kernel = kernel object,  anchor = position of the anchor
+*               : iterations = nuber of times applied, borderType = border type,
+*               : borderValue = border value
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+************************************************************/
+static int morphOp_drp(int op, InputArray _src, OutputArray _dst,
+                        InputArray _kernel,
+                        Point anchor, int iterations,
+                        int borderType, const Scalar &borderValue)
+{
+    CV_LOG_INFO(nullptr, "morphOp_drp start.");
+
+    /* in this version it can support dilate or erode */
+    if (MORPH_DILATE != op && MORPH_ERODE != op)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set morphology parameter */
+    uint16_t circuilt_no = 0;
+
+    switch (op)
+    {
+    case MORPH_DILATE:
+        circuilt_no = PARAM_NO_MORPH_DILATE;
+        break;
+
+    case MORPH_ERODE:
+        circuilt_no = PARAM_NO_MORPH_ERODE;
+        break;
+
+    default:
+        break;
+    }
+ 
+    /* exec drp function process */
+
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(circuilt_no);
+
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* convert to mat object */
+    Mat src_mat = _src.getMat();
+
+    /* first, check can exec drp circuit */
+    uint32_t src_width = src_mat.cols;
+    uint32_t src_height = src_mat.rows;
+    uint32_t dst_width = src_width;
+    uint32_t dst_height = src_height;
+    uint16_t src_ch = src_mat.channels();
+    uint8_t *out_image_buffer;
+
+    /* width */
+    if (3840 < src_width || 16 > src_width || 0 != src_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* height */
+    if (2160 < src_height || 16 > src_height || 0 != src_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* src image size */
+    if (3840 * 2160 < src_width * src_height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if (1 > src_mat.channels() || 4 < src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if (CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* borderType */
+    if (borderType != BORDER_CONSTANT && borderType != BORDER_REPLICATE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* kernel */
+    Mat kernel = _kernel.getMat();
+    Size ksize = !kernel.empty() ? kernel.size() : Size(3, 3);
+
+    if (ksize != Size(3, 3))
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* Anchor */
+    if (anchor != Point(-1, -1))
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* Iterations */
+    if (1 > iterations || 3840 < iterations)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* border value */
+    const Scalar defaultBorderValue = morphologyDefaultBorderValue();
+    if (defaultBorderValue != borderValue)
+    {
+        return DRP_NOT_EXECUTE; 
+    }
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    /* it is nesessary to create dst mat object. */
+    int type = _src.type();
+    Size size = _src.size();
+    _dst.create(size, type);
+
+    Mat dst_mat = _dst.getMat();
+
+    int result = DRP_NORMAL_END;
+
+    /* set in process flag */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* set morphology parameter */
+    result = drp->setMorphologyParameter(src_width, src_height, src_ch, iterations, borderType, borderValue[0], circuilt_no);
+
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->setSrcImage(src_mat.data);
+
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->execDRP();
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    out_image_buffer = new uint8_t[src_width * src_height * src_ch];
+
+    result = drp->readDstImage(out_image_buffer);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat dst_mat_out = Mat(dst_height, dst_width, src_mat.type(), out_image_buffer);
+    dst_mat_out.copyTo(dst_mat);
+
+    delete[] out_image_buffer;
+
+    CV_LOG_INFO(nullptr, "morphOp_drp end.");
+
+    /* reset in process flag */
+    drp->set_drp_end();
+
+    return result;
+}
+
 void erode( InputArray src, OutputArray dst, InputArray kernel,
                 Point anchor, int iterations,
                 int borderType, const Scalar& borderValue )
@@ -1009,7 +1220,18 @@ void erode( InputArray src, OutputArray dst, InputArray kernel,
 
     CV_Assert(!src.empty());
 
-    morphOp( MORPH_ERODE, src, dst, kernel, anchor, iterations, borderType, borderValue );
+    CV_LOG_INFO(nullptr, "start erode filter.");
+
+    int ret_drp = DRP_NORMAL_END;
+    ret_drp = morphOp_drp(MORPH_ERODE, src, dst, kernel, anchor, iterations, borderType, borderValue);
+
+    if (DRP_NOT_EXECUTE == ret_drp)
+    {
+        CV_LOG_INFO(nullptr, "exec normal erode.");
+        morphOp(MORPH_ERODE, src, dst, kernel, anchor, iterations, borderType, borderValue);
+    }
+
+    CV_LOG_INFO(nullptr, "erode filter end.");
 }
 
 
@@ -1021,7 +1243,18 @@ void dilate( InputArray src, OutputArray dst, InputArray kernel,
 
     CV_Assert(!src.empty());
 
-    morphOp( MORPH_DILATE, src, dst, kernel, anchor, iterations, borderType, borderValue );
+    CV_LOG_INFO(nullptr, "dilate method start.");
+
+    int ret_drp = DRP_NORMAL_END;
+    ret_drp = morphOp_drp(MORPH_DILATE, src, dst, kernel, anchor, iterations, borderType, borderValue);
+
+    if (DRP_NOT_EXECUTE == ret_drp)
+    {
+        CV_LOG_INFO(nullptr, "exec normal dilate.");
+        morphOp(MORPH_DILATE, src, dst, kernel, anchor, iterations, borderType, borderValue);
+    }
+
+    CV_LOG_INFO(nullptr, "dilate filter end.");
 }
 
 #ifdef HAVE_OPENCL
diff --git a/modules/imgproc/src/pyramids.cpp b/modules/imgproc/src/pyramids.cpp
index 52f9573..f68a79c 100644
--- a/modules/imgproc/src/pyramids.cpp
+++ b/modules/imgproc/src/pyramids.cpp
@@ -46,6 +46,9 @@
 #include "opencv2/core/hal/intrin.hpp"
 
 #include "opencv2/core/openvx/ovx_defs.hpp"
+#include <opencv2/core/utils/logger.hpp>
+
+#include <rzv2ma_drp.h>
 
 namespace cv
 {
@@ -1408,6 +1411,165 @@ static bool openvx_pyrDown( InputArray _src, OutputArray _dst, const Size& _dsz,
 }
 #endif
 
+/**************************************************************************************************************
+* Method Name   : cv::pyrDown_drp()
+* Description   : exec pyrDown drp version
+* Arguments     : _src = src image, _dst = src image height, src_ch = src image channels,
+                  dsize_width = output image width, dsize_height = output image height,
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+***************************************************************************************************************/
+int cv::pyrDown_drp(InputArray _src, OutputArray _dst, const Size& _dsz, int borderType)
+{
+    CV_LOG_INFO(nullptr, "pyrDown_drp start.");
+    
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        CV_LOG_INFO(nullptr, "pyrDown_drp get instance");
+        return DRP_NOT_EXECUTE;
+    }
+
+    int result = DRP_NORMAL_END;
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_PYRDOWN);
+    
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        CV_LOG_INFO(nullptr, "pyrDown_drp inactive.");
+        return DRP_NOT_EXECUTE;
+    }
+
+    CV_LOG_INFO(nullptr, "pyrDown_drp active.");
+
+    /* output image buffer */
+    uint8_t *out_image_buffer;
+
+    /* to convert to Mat class */ 
+    Mat src_mat = _src.getMat();
+    Mat dst_mat = _dst.getMat();
+
+    /* set width height ch */
+    uint16_t src_width = src_mat.size().width;
+    uint16_t src_height = src_mat.size().height;
+
+    uint16_t dst_width = _dsz.width;
+    uint16_t dst_height = _dsz.height;
+    uint16_t src_ch = src_mat.channels();
+    uint16_t dst_ch = src_mat.channels();
+
+    if(_dsz.empty())
+    {
+        dst_height = src_height / 2;
+        dst_width = src_width / 2;
+    }
+  
+    /* src width */
+    if(3840 < src_width || 16 > src_width || 0 != src_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* src height */
+    if(2160 < src_height || 16 > src_height || 0 != src_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if(1 > src_mat.channels() || 4 < src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if(CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+   
+    /* check output size rate */
+    if(src_width / 2 != dst_width || src_height / 2 != dst_height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* borderType */
+    if(borderType != BORDER_DEFAULT)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    out_image_buffer = new uint8_t[dst_width*dst_height*dst_ch];
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+ 
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        CV_LOG_INFO(nullptr, "pyrUp_down read header error.");
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+    
+    /* to set pyrDown parameter */
+    result = drp->setPyrDownParameter(src_width, src_height, src_ch, dst_width, dst_height);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set pryDown src image to drp input area */
+    result = drp->setSrcImage(src_mat.data);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* executing drp process */
+    result = drp->execDRP();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to read pryDown dst image from drp output area */
+    result = drp->readDstImage(out_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to convert mat object */
+    Mat dst_mat_out =  Mat(dst_height, dst_width, CV_8UC(dst_ch), out_image_buffer);
+    dst_mat_out.copyTo(_dst);
+
+    delete[] out_image_buffer;
+
+    drp->set_drp_end();
+    CV_LOG_INFO(nullptr, "pyrDown_drp end.");
+
+    return DRP_NORMAL_END;
+}
+
 void cv::pyrDown( InputArray _src, OutputArray _dst, const Size& _dsz, int borderType )
 {
     CV_INSTRUMENT_REGION();
@@ -1435,6 +1597,14 @@ void cv::pyrDown( InputArray _src, OutputArray _dst, const Size& _dsz, int borde
     CV_IPP_RUN(borderTypeNI == BORDER_DEFAULT && (!_src.isSubmatrix() || isolated) && dsz == Size((_src.cols() + 1)/2, (_src.rows() + 1)/2),
         ipp_pyrdown( _src,  _dst,  _dsz,  borderType));
 
+    /* exec drp function */
+    int result = cv::pyrDown_drp(_src, _dst, _dsz, borderType);
+    if(result == DRP_NORMAL_END)
+    {
+        return;
+    }
+
+    CV_LOG_INFO(nullptr, "pyrDown_drp continue to normal opencv.");
 
     PyrFunc func = 0;
     if( depth == CV_8U )
@@ -1515,6 +1685,163 @@ static bool ipp_pyrup( InputArray _src, OutputArray _dst, const Size& _dsz, int
 }
 #endif
 
+/**************************************************************************************************************
+* Method Name   : cv::pyrUp_drp()
+* Description   : exec pyrUp drp version
+* Arguments     : _src = src image, _dst = src image height, src_ch = src image channels,
+                  dsize_width = output image width, dsize_height = output image height,
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+***************************************************************************************************************/
+int cv::pyrUp_drp(InputArray _src, OutputArray _dst, const Size& _dsz, int borderType)
+{
+    CV_LOG_INFO(nullptr, "pyrUp_drp start.");
+    
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        CV_LOG_INFO(nullptr, "pyrUp_drp get instance");
+        return DRP_NOT_EXECUTE;
+    }
+
+    int result = DRP_NORMAL_END;
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_PYRUP);
+    
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        CV_LOG_INFO(nullptr, "pyrUp_drp inactive.");
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* output image buffer */
+    uint8_t *out_image_buffer;
+
+    /* to convert to Mat class */ 
+    Mat src_mat = _src.getMat();
+    Mat dst_mat = _dst.getMat();
+
+    /* set width height ch */
+    uint16_t src_width = src_mat.size().width;
+    uint16_t src_height = src_mat.size().height;
+
+    uint16_t dst_width = _dsz.width;
+    uint16_t dst_height = _dsz.height;
+    uint16_t src_ch = src_mat.channels();
+    uint16_t dst_ch = src_mat.channels();
+
+    if(_dsz.empty())
+    {
+        dst_height = src_height * 2;
+        dst_width = src_width * 2;
+    }
+  
+    /* src width */
+    if(1920 < src_width || 8 > src_width || 0 != src_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* src height */
+    if(1080 < src_height || 8 > src_height || 0 != src_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if(1 > src_mat.channels() || 4 < src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if(CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+   
+    /* check output size rate */
+    if(src_width*2 != dst_width || src_height*2 != dst_height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* borderType */
+    if(borderType != BORDER_DEFAULT)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    out_image_buffer = new uint8_t[dst_width*dst_height*dst_ch];
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+ 
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        CV_LOG_INFO(nullptr, "pyrUp_drp read header error.");
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+    
+    /* to set pyrUp parameter */
+    result = drp->setPyrUpParameter(src_width, src_height, src_ch, dst_width, dst_height);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set pyrUp src image to drp input area */
+    result = drp->setSrcImage(src_mat.data);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* executing drp process */
+    result = drp->execDRP();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to read pyrUp dst image from drp output area */
+    result = drp->readDstImage(out_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to convert mat object */
+    Mat dst_mat_out =  Mat(dst_height, dst_width, CV_8UC(dst_ch), out_image_buffer);
+    dst_mat_out.copyTo(_dst);
+
+    delete[] out_image_buffer;
+
+    drp->set_drp_end();
+    CV_LOG_INFO(nullptr, "pyrUp_drp end.");
+
+    return DRP_NORMAL_END;
+}
+
 void cv::pyrUp( InputArray _src, OutputArray _dst, const Size& _dsz, int borderType )
 {
     CV_INSTRUMENT_REGION();
@@ -1538,6 +1865,13 @@ void cv::pyrUp( InputArray _src, OutputArray _dst, const Size& _dsz, int borderT
     CV_IPP_RUN(borderTypeNI == BORDER_DEFAULT && (!_src.isSubmatrix() || isolated) && dsz == Size(_src.cols()*2, _src.rows()*2),
         ipp_pyrup( _src,  _dst,  _dsz,  borderType));
 
+    int result = cv::pyrUp_drp(_src, _dst, _dsz, borderType);
+    if(result == DRP_NORMAL_END)
+    {
+        return;
+    }
+
+    CV_LOG_INFO(nullptr, "pyrUp_drp continue to normal opencv.");
 
     PyrFunc func = 0;
     if( depth == CV_8U )
diff --git a/modules/imgproc/src/resize.cpp b/modules/imgproc/src/resize.cpp
index 0943e97..ef7c0c0 100644
--- a/modules/imgproc/src/resize.cpp
+++ b/modules/imgproc/src/resize.cpp
@@ -59,6 +59,11 @@
 #include "opencv2/core/softfloat.hpp"
 #include "fixedpoint.inl.hpp"
 
+#include <rzv2ma_drp.h>
+#include <opencv2/core/utils/logger.hpp>
+
+#include <unistd.h>
+
 using namespace cv;
 
 namespace
@@ -4138,6 +4143,192 @@ void resize(int src_type,
 }
 
 } // cv::hal::
+
+/*****************************************
+* Method Name   : resize_drp
+* Description   : to exec drp process of OpenCV accelerator resize.
+* Arguments     : _src = src image(Mat), _dst = dst image(Mat), dsize = src image size,
+                  inv_scale_x = resize scale for x, inv_scale_y = resize scale for y, interpolation) = dst image channels,
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+******************************************/
+int resize_drp(InputArray _src, OutputArray _dst, Size dsize, double inv_scale_x, double inv_scale_y, int interpolation)
+{
+    CV_LOG_INFO(nullptr, "resize_drp start.");
+
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        CV_LOG_INFO(nullptr, "resize_drp get instance");
+        return DRP_NOT_EXECUTE;
+    }
+
+    int result = DRP_NORMAL_END;
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_RESIZE);
+
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to convert to Mat class */
+    Mat src_mat = _src.getMat();
+
+    /* to set resize spec */
+    uint32_t src_width = src_mat.size().width;
+    uint32_t src_height = src_mat.size().height;
+    uint32_t src_ch = src_mat.channels();
+    int src_depth = src_mat.depth();
+
+    static const uint32_t img_max_width = 3840, img_max_height = 2160;
+
+    /* checking src image size */
+    if (2 > src_width)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+    if (2 > src_height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+    if(img_max_width < src_width)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+    if(img_max_height < src_height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* checking channel size */
+    if((1 > src_ch) || (4 < src_ch))
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* Check depth */
+    if(CV_8U != src_depth)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* dst src size */
+    uint32_t dst_width = 0;
+    uint32_t dst_height = 0;
+    uint16_t dst_ch = src_ch;
+
+    /* output image buffer */
+    uint8_t *out_image_buffer;
+
+    /* check input size */
+    if(0 < dsize.area())
+    {
+        dst_width = dsize.width;
+        dst_height = dsize.height;
+    }
+    else
+    {
+        // need to cast integer to double for small scale
+        dst_width = round( (double)src_width * inv_scale_x );
+        dst_height = round( (double)src_height * inv_scale_y );
+    }
+
+    if(2 > dst_width)
+    {
+            return DRP_NOT_EXECUTE;
+    }
+    if(2 > dst_height)
+    {
+            return DRP_NOT_EXECUTE;
+    }
+
+    if(img_max_width < dst_width) // cast opencv type to unsigned
+    {
+         return DRP_NOT_EXECUTE;
+    }
+    if(img_max_height < dst_height) // cast opencv type to unsigned
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* checking algorizm */
+    if(INTER_LINEAR != interpolation)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    out_image_buffer = new uint8_t[dst_width*dst_height*dst_ch];
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        CV_LOG_INFO(nullptr, "resize_drp read header error.");
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set resize parameter */
+    result = drp->setResizeParameter(src_width, src_height, src_ch, dst_width, dst_height, dst_ch);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set resize src image to drp input area */
+    result = drp->setSrcImage(src_mat.data);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* executing drp process */
+    result = drp->execDRP();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to read resize dst image from drp output area */
+    result = drp->readDstImage(out_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to convert mat object */
+    Mat dst_mat_out =  Mat(dst_height, dst_width, CV_8UC(dst_ch), out_image_buffer);
+    dst_mat_out.copyTo(_dst);
+
+    delete[] out_image_buffer;
+
+    drp->set_drp_end();
+
+    CV_LOG_INFO(nullptr, "resize_drp end.");
+
+    return DRP_NORMAL_END;
+}
+
 } // cv::
 
 //==================================================================================================
@@ -4147,6 +4338,18 @@ void cv::resize( InputArray _src, OutputArray _dst, Size dsize,
 {
     CV_INSTRUMENT_REGION();
 
+    CV_LOG_INFO(nullptr, "resize method start.");
+
+    /* First, to call drp process */
+    int result = cv::resize_drp(_src, _dst, dsize, inv_scale_x, inv_scale_y, interpolation);
+    if(result == DRP_NORMAL_END)
+    {
+        return;
+    }
+
+    /* If could not execute drp process, then to call normal opencv method */
+    CV_LOG_INFO(nullptr, "exec normal resize method.");
+
     Size ssize = _src.size();
 
     CV_Assert( !ssize.empty() );
diff --git b/modules/imgproc/src/rzv2ma_drp.cpp b/modules/imgproc/src/rzv2ma_drp.cpp
new file mode 100644
index 0000000..4c3ad74
--- /dev/null
+++ b/modules/imgproc/src/rzv2ma_drp.cpp
@@ -0,0 +1,2665 @@
+/***********************************************************************************************************************
+* DISCLAIMER
+* This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products. No
+* other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all
+* applicable laws, including copyright laws.
+* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED. TO THE MAXIMUM
+* EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES
+* SHALL BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS
+* SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+* Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability of
+* this software. By using this software, you agree to the additional terms and conditions found by accessing the
+* following link:
+* http://www.renesas.com/disclaimer
+*
+* Copyright (C) 2022 Renesas Electronics Corporation. All rights reserved.
+***********************************************************************************************************************/
+/***********************************************************************************************************************
+* File Name    : rzv2m_drp.cpp
+* Version      : 1.00
+* Description  : Call RZ/V2M From OpenCV Accelerator POC
+***********************************************************************************************************************/
+/*****************************************
+* Includes
+******************************************/
+#include <iostream>
+#include <stdlib.h>
+#include <stdio.h>
+#include <memory.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <mutex>
+#include <semaphore.h>
+
+#include <thread>
+#include <sstream>
+#include <rzv2ma_drp.h>
+#include <opencv2/core/base.hpp>
+#include <opencv2/core/utils/logger.hpp>
+
+/*****************************************
+*  MACROS/DEFINES
+******************************************/
+#define SHM_SEMAPHORE_PATH    "/libdrp_api.so"
+#define SEM_TIMEOUT_SEC      (60) /* 60sec */
+#define SEM_TIMEOUT_NSEC     (60 * 1e6) /* 60msec */
+
+/* single instance of rzv2m drp */
+rzv2m_drp* rzv2m_drp::_singleton = NULL;
+
+/* conflict notification action */
+int rzv2m_drp::drp_conflict_exception = 0;
+
+/* mutex for oca_activate */
+std::mutex drp_mutex;
+
+/* mutex for oca_conflict_notification */
+std::mutex drp_conflict_mutex;
+
+/* mutex for initialize sequence */
+std::mutex drp_initialize_mutex;
+
+/* mutex for initialize for api sequence */
+std::mutex drp_init_for_api_mutex;
+
+/* semaphore for initializing */
+static int g_initializing = 0;
+
+/* semaphore for result */
+static sem_t * g_sem = NULL;
+
+/* semaphore for waiting process counter*/
+static int waiting_count = 0;
+
+/*****************************************
+* Method Name   : rzv2m_drp
+* Description   : Constructor
+******************************************/
+rzv2m_drp::rzv2m_drp()
+{
+}
+
+/*****************************************
+* Method Name   : get_instance
+* Description   : initializing and return single instance
+* Arguments     : void
+* Return value  : rzv2m_drp single instance
+******************************************/
+rzv2m_drp* rzv2m_drp::get_instance()
+{
+    drp_initialize_mutex.lock();
+
+    /* check initialize if not exec initialize */
+    if(_singleton == NULL) 
+    {
+        _singleton = new rzv2m_drp();
+        _singleton->initialize();
+    }
+
+    drp_initialize_mutex.unlock();
+
+    return _singleton;
+}
+
+/**********************************************************************
+* Method Name   : get_instance_forapi
+* Description   : initializing and return single instance for api
+* Arguments     : void
+* Return value  : rzv2m_drp single instance
+***********************************************************************/
+rzv2m_drp* rzv2m_drp::get_instance_forapi()
+{
+    drp_init_for_api_mutex.lock();
+
+    /* check initialize if not exec initialize */
+    if(_singleton == NULL) 
+    {
+        _singleton = new rzv2m_drp();
+        _singleton->initialize();
+    }
+
+    drp_init_for_api_mutex.unlock();
+
+    return _singleton;
+}
+
+/*************************************************************************************
+* Method Name   : OCA_Activate
+* Description   : activate or inactivate
+* Arguments     : unsigned long* OCA_list: input param to activate or to inactivate
+* Return value  : int DRP_NORMAL_END(0) or DRP_PARAM_ERROR(-1)
+**************************************************************************************/
+int rzv2m_drp::OCA_Activate(unsigned long* OCA_list)
+{
+    if(OCA_list == NULL)
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    drp_mutex.lock();
+
+    /* get circuit count (already read opencv_bin address info) */
+    int circuit_cnt = (opencv_bin_config_base - opencv_bin_list_base) / 32;
+    if( circuit_cnt >= DRP_CIRCUIT_CNT_MAX)
+    {
+       circuit_cnt = DRP_CIRCUIT_CNT_MAX; 
+    }
+
+    /* set to each input param to each possible flag */
+    uint32_t api_possiblef = 0;
+    uint32_t* p_api_possiblef = 0;
+
+    opencv_bin_list_base = *(uint32_t *)(&opencv_bin_p[24]);
+
+    for(int i=0; i<circuit_cnt; i++)
+    {
+        api_possiblef = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*i]);    // existence flag of circuit data 
+        p_api_possiblef = (uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*i]);    // existence flag of circuit data 
+
+        /* check input param value is valid */
+        if( (OCA_list[i] != CIRCUIT_INPARAM_INACTIVATE) && (OCA_list[i] != CIRCUIT_INPARAM_ACTIVATE) )
+        {
+            continue;
+        }
+
+        /* check if circuit exists */
+        if(api_possiblef == CIRCUIT_POSSIBLEF_NOT_EXIST)
+        {
+            /* can do nothing */
+            continue;    
+        }
+
+        /* set to active or inactive */
+        if(OCA_list[i] == CIRCUIT_INPARAM_ACTIVATE)
+        {
+            /* activate (to active) */
+            *p_api_possiblef = CIRCUIT_POSSIBLEF_ACTIVE;
+        }
+        else if(OCA_list[i] == CIRCUIT_INPARAM_INACTIVATE)
+        {
+            /* inactivate (to inactivate) */
+            *p_api_possiblef = CIRCUIT_POSSIBLEF_INACTIVE;
+        }
+    }
+
+    drp_mutex.unlock();
+
+    return DRP_NORMAL_END;
+}
+
+/*************************************************************************************
+* Method Name   : OCA_ConflictNotification
+* Description   : set conflict ation flag
+* Arguments     : int oca_conflict
+* Return value  : void
+**************************************************************************************/
+void rzv2m_drp::OCA_ConflictNotification(int oca_conflict)
+{
+    drp_conflict_mutex.lock();
+    
+    rzv2m_drp::drp_conflict_exception = oca_conflict;
+
+    drp_conflict_mutex.unlock();
+    
+    return;
+}
+
+/*************************************************************************************
+* Method Name   : conflict_action_exec
+* Description   : execute conflict atcion (CV_Error or normal opencv method)
+* Arguments     : void
+* Return value  : void
+**************************************************************************************/
+ void rzv2m_drp::conflict_action_exec(void)
+ {
+    /* default action */
+    if(rzv2m_drp::drp_conflict_exception == 0)
+    {
+        CV_Error(cv::Error::OpenCVADRPConflict, "OpenCVA DRP resource conflict.");
+    }
+
+    /* if rzv2m_drp::drp_conflict_exception is not 0 */
+    /* then exec normal opencv method */
+     
+    return;
+ }
+
+/*************************************************************************************
+* Method Name   : get_drp_possiblef
+* Description   : get circuite possible flag
+* Arguments     : uint16_t circuit_no:circuite function no
+* Return value  : drp_possible_flag
+**************************************************************************************/
+int rzv2m_drp::get_drp_possiblef(uint16_t circuit_no)
+{
+    uint32_t drp_possible_flag = -1;
+
+    char* signature_p = (char *)(&opencv_bin_p[0]);           // pointer to signature(16byte)
+    uint32_t list_base = *(uint32_t *)(&opencv_bin_p[24]);     // opencva list address(offset value)
+
+    if(!initialized || signature_p == NULL)
+    {
+        return drp_possible_flag;
+    }
+
+    drp_possible_flag = *(uint32_t *)(&opencv_bin_p[list_base + 32*circuit_no]);
+
+    return (int)drp_possible_flag;
+}
+
+/*********************************************************
+* Method Name   : readBinaryHeader
+* Description   : reading opencv binary header information
+* Arguments     : void
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+**********************************************************/
+int rzv2m_drp::readBinaryHeader(void)
+{
+    if(!initialized)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(strcmp(opencv_bin_signature_p, OCABIN_SIGNATURE) != 0)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/**************************************************************************************************************
+* Method Name   : setResizeParameter
+* Description   : to set resize parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, src_ch = src image channels,
+                  dst_width = dst image width, dst_height = dst image height, dst_ch = dst image channels,
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+***************************************************************************************************************/
+int rzv2m_drp::setResizeParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dst_width, uint16_t dst_height, uint16_t dst_ch)
+{
+    int ret = 0;
+    int circuit_no = PARAM_NO_RESIZE; // resize circuit index
+    uint8_t drp_resize_param[PARAM_SIZE_RESIZE]; 
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dst_width * dst_height * dst_ch;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);    // existence flag of circuit data 
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);// address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);// size of resize circuit
+    
+    /*  calculate address value of input image and output image */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next to DRP parameter area
+    dst_adr = src_adr + src_size;
+    tmpl_adr = NULL;    //for 40bit addr
+    map_adr = NULL;
+    
+    dst_adr_64aligment();
+                            
+    /* set resize drp rapameter to local variables */
+    *((uint32_t *)(&drp_resize_param[0]))  = src_adr;   //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_resize_param[4]))  = dst_adr;   //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_resize_param[8]))  = src_width; //input width(pixel)
+    *((uint16_t *)(&drp_resize_param[10])) = src_height;//input height(pixel)
+    *((uint16_t *)(&drp_resize_param[12])) = src_ch;    //input channels
+    *((uint16_t *)(&drp_resize_param[14])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_resize_param[16])) = dst_width; //output width(pixel)
+    *((uint16_t *)(&drp_resize_param[18])) = dst_height;//output width(pixel)
+    *((uint16_t *)(&drp_resize_param[20])) = dst_ch;    //output channels
+    *((uint16_t *)(&drp_resize_param[22])) = 0;         //reserved(0)
+    memset( &drp_resize_param[24],0,16);                //Not used(0)
+    *((uint16_t *)(&drp_resize_param[40])) = 0;         //CPU ionterupt on (0 fixed)
+    memset( &drp_resize_param[42],0,6);                 //reserved(0 fixed)
+    *((uint16_t *)(&drp_resize_param[48])) = 1;         //bylinear
+    *((uint16_t *)(&drp_resize_param[50])) = 0;         //U8
+    *((uint16_t *)(&drp_resize_param[52])) = 0;         //reserved(0 fixed)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // pysical address 
+    proc[DRPPARAM1].size = PARAM_SIZE_RESIZE;// size of param (56 byte)
+                               
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]);   // to assign to drp area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    do
+    {
+        errno= 0;
+        ret = write(fd_drp, drp_resize_param, PARAM_SIZE_RESIZE);  // to write parameter to specified address
+    } while ((-1 == ret) && (ERESTART == errno));
+        
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if ( ret != PARAM_SIZE_RESIZE)
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/**************************************************************************************************************************
+* Method Name   : setYUV2RGBParameter
+* Description   : to set YUV2RGB parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, input_size = src image size,
+                  input_format = input format, src_width = dst image width, dst_height = dst image height, 
+                  output_format = output format(rgb or gbr)
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+***************************************************************************************************************************/
+int rzv2m_drp::setYUV2RGBParameter(uint16_t src_width, uint16_t src_height, uint32_t input_size, uint16_t input_format,
+                uint16_t dst_width, uint16_t dst_height, uint16_t output_format)
+{
+    int ret = 0;
+
+    src_size = input_size;
+
+    int circuit_no = PARAM_NO_YUV2RGB; 
+    uint8_t drp_yuv2rgb_param[PARAM_SIZE_YUV2RGB]; 
+
+    dst_size = dst_width * dst_height * 3;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);    // existence flag of circuit data
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);// address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);// size of resize circuit
+    
+    /*  calculate address value of input image and output image */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next to DRP parameter area
+    dst_adr = src_adr + src_size;
+    tmpl_adr = NULL;    //for 40bit addr
+    map_adr = NULL;
+
+    dst_adr_64aligment();
+
+    /* set yuv2rgb drp rapameter to local variables */
+    *((uint32_t *)(&drp_yuv2rgb_param[0]))  = src_adr;   //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_yuv2rgb_param[4]))  = dst_adr;   //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_yuv2rgb_param[8]))  = src_width; //input width(pixel)
+    *((uint16_t *)(&drp_yuv2rgb_param[10])) = src_height;//input height(pixel)
+    *((uint16_t *)(&drp_yuv2rgb_param[12])) = 0;         //reserved(0 fixed)
+    *((uint16_t *)(&drp_yuv2rgb_param[14])) = 0;         //reserved(0 fixed)
+    *((uint16_t *)(&drp_yuv2rgb_param[16])) = dst_width; //output width(pixel)
+    *((uint16_t *)(&drp_yuv2rgb_param[18])) = dst_height;//output width(pixel)
+    *((uint16_t *)(&drp_yuv2rgb_param[20])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_yuv2rgb_param[22])) = 0;         //reserved(0)
+    memset( &drp_yuv2rgb_param[24],0,16);                //Not used(0)
+    *((uint16_t *)(&drp_yuv2rgb_param[40])) = 0;         //CPU ionterupt on (0 fixed)
+    memset( &drp_yuv2rgb_param[42],0,6);                 //reserved(0)
+    *((uint16_t *)(&drp_yuv2rgb_param[48])) = input_format;//input format
+    *((uint16_t *)(&drp_yuv2rgb_param[50])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_yuv2rgb_param[52])) = output_format;//output format
+    *((uint16_t *)(&drp_yuv2rgb_param[54])) = 0;         //reserved(0)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // pysical address 
+    proc[DRPPARAM1].size = PARAM_SIZE_YUV2RGB;// size of param (56 byte)
+                               
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]); // to assign to drp area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    do
+    {
+        errno= 0;
+        ret = write(fd_drp, drp_yuv2rgb_param, PARAM_SIZE_RESIZE); // to write parameter to specified address
+    } while ((-1 == ret) && (ERESTART == errno));
+        
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+    
+    if ( ret != PARAM_SIZE_RESIZE)
+    {
+        return DRP_PARAM_ERROR;
+    }
+    
+    return DRP_NORMAL_END;
+}
+
+/****************************************************************************
+* Method Name   : setYUV2NVParameter
+* Description   : to set YUV2nv parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, 
+                  input_yuv = input yuv format, 
+                  output_nv = output nv
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+*****************************************************************************/
+int rzv2m_drp::setYUV2NVParameter(uint16_t src_width, uint16_t src_height, uint16_t input_yuv, uint16_t output_nv)
+{	
+    int ret = 0;
+
+    uint16_t dst_width = src_width;
+    uint16_t dst_height = src_height;
+
+    src_size = src_width * src_height * 2;
+    dst_size = dst_width * dst_height * 3 / 2;
+
+    int circuit_no = PARAM_NO_YUV2NV; 
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);    // existence flag of circuit data
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);// address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);// size of resize circuit
+    
+    uint8_t drp_yuv2nv_param[PARAM_SIZE_YUV2NV12];   // define parameter area
+        
+    /*  calculate address value of input image and output image */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next address to drp parameter
+    dst_adr = src_adr + src_size; // next address to input image
+    tmpl_adr = NULL;    //for 40bit addr
+    map_adr = NULL;
+
+    dst_adr_64aligment();
+
+    /* set YUV2NV drp rapameter to local variables */
+    *((uint32_t *)(&drp_yuv2nv_param[0]))  = src_adr;   //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_yuv2nv_param[4]))  = dst_adr;   //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_yuv2nv_param[8]))  = src_width; //src image width(pixel)
+    *((uint16_t *)(&drp_yuv2nv_param[10])) = src_height;//src image height(pixel)
+    *((uint16_t *)(&drp_yuv2nv_param[12])) = 0;         //reserved(0 fixed)
+    *((uint16_t *)(&drp_yuv2nv_param[14])) = 0;         //reserved(0 fixed)
+    *((uint16_t *)(&drp_yuv2nv_param[16])) = dst_width; //dst image width(pixel)
+    *((uint16_t *)(&drp_yuv2nv_param[18])) = dst_height;//dst image height(pixel)
+    *((uint16_t *)(&drp_yuv2nv_param[20])) = 0;         //reserved(0 fixed)
+    *((uint16_t *)(&drp_yuv2nv_param[22])) = 0;         //reserved(0 fixed)
+    memset( &drp_yuv2nv_param[24],0,16);                //Not used
+    *((uint16_t *)(&drp_yuv2nv_param[40])) = 0;         //CPU interrupt enable(0 fixed)
+    memset( &drp_yuv2nv_param[42],0,6);                 //reserved(0 fixed)
+    *((uint16_t *)(&drp_yuv2nv_param[48])) = input_yuv; //input yuv format
+    *((uint16_t *)(&drp_yuv2nv_param[50])) = 0;         //reserved(0 fixed)
+    *((uint16_t *)(&drp_yuv2nv_param[52])) = output_nv; //output nv format
+    *((uint16_t *)(&drp_yuv2nv_param[54])) = 0;         //reserved(0 fixed)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // pysical address 
+    proc[DRPPARAM1].size = PARAM_SIZE_YUV2NV12;                          // 56byte
+    do
+        {
+            errno= 0;
+            ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]);  // to access memory area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((0 != ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if (!((0 == ret) && (0 == errno)))
+        {
+            return DRP_PARAM_ERROR;
+        }
+    do
+        {
+            errno= 0;
+            ret = write(fd_drp, drp_yuv2nv_param, PARAM_SIZE_YUV2NV12); // to write parameter to assigned address
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((-1 == ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if ( ret != PARAM_SIZE_YUV2NV12)
+        {
+            return DRP_PARAM_ERROR; 
+        }
+
+    return DRP_NORMAL_END;	
+}
+
+/***************************************************************************
+* Method Name   : setGaussianParameter
+* Description   : to set Gaussian filter parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, 
+                  src_ch = src channels number, kernel_size = kernel size 
+                  output_nv = output nv
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+****************************************************************************/
+int rzv2m_drp::setGaussianParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch, uint16_t kernel_size)
+{
+    int ret = 0;
+
+    /* set dst image size same as src size */
+    uint16_t dst_width = src_width;
+    uint16_t dst_height = src_height;
+    uint16_t dst_ch = src_ch;
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dst_width * dst_height * dst_ch;
+
+    int circuit_no = PARAM_NO_GAUSSIAN; 
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);    // existence flag of circuit data
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);// address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);// size of resize circuit
+    
+    uint8_t drp_gaussian_param[PARAM_SIZE_GAUSSIAN];
+        
+    /* to write drp parameters to memory area */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next address to drp parameter
+    dst_adr = src_adr + src_size; // next address to input image
+    tmpl_adr = NULL;    //for 40bit addr
+    map_adr = NULL;
+
+    dst_adr_64aligment();
+
+    /* set gaussian drp rapameter to local variables */
+    *((uint32_t *)(&drp_gaussian_param[0]))  = src_adr;   //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_gaussian_param[4]))  = dst_adr;   //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_gaussian_param[8]))  = src_width; //src width(pixel)
+    *((uint16_t *)(&drp_gaussian_param[10])) = src_height;//src height(pixel)
+    *((uint16_t *)(&drp_gaussian_param[12])) = src_ch;    //src channel
+    *((uint16_t *)(&drp_gaussian_param[14])) = 0;         //reserved(0 fixed)
+    *((uint16_t *)(&drp_gaussian_param[16])) = dst_width; //dst width(pixel)
+    *((uint16_t *)(&drp_gaussian_param[18])) = dst_height;//dst width(pixel)
+    *((uint16_t *)(&drp_gaussian_param[20])) = dst_ch;    //dst channel
+    *((uint16_t *)(&drp_gaussian_param[22])) = 0;         //reserved(0 fixed)
+    memset( &drp_gaussian_param[24],0,16);                //Not used(0 fixed)
+    *((uint16_t *)(&drp_gaussian_param[40])) = 0;         //CPU interrupt enable(0 fixed)
+    memset( &drp_gaussian_param[42],0,6);                 //reserved(0 fixed)
+    *((uint16_t *)(&drp_gaussian_param[48])) = kernel_size; //kernel size         
+    *((uint16_t *)(&drp_gaussian_param[50])) = 0;         //reserved(0 fixed)
+    *((uint16_t *)(&drp_gaussian_param[52])) = 0;         //reserved(0 fixed)
+    *((uint16_t *)(&drp_gaussian_param[54])) = 0;         //reserved(0 fixed)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // assign pysical address
+    proc[DRPPARAM1].size = PARAM_SIZE_GAUSSIAN;    // gaussian parameter size
+    do
+        {
+            errno= 0;
+            ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]); // to access memory area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((0 != ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if (!((0 == ret) && (0 == errno)))
+        { 
+            return DRP_PARAM_ERROR; 
+        }
+    do
+        {
+            errno= 0;
+            ret = write(fd_drp, drp_gaussian_param, PARAM_SIZE_GAUSSIAN); // to write parameter to assigned area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((-1 == ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if (ret != PARAM_SIZE_GAUSSIAN)
+        {
+            return DRP_PARAM_ERROR;   
+        }
+    
+    return DRP_NORMAL_END;
+}
+
+/***************************************************************************
+* Method Name   : setMorphologyParameter
+* Description   : to set Morphology(dilate,erode) filter parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, 
+                  src_ch = src channels number, iterators = iterators size 
+                  border_type = border type, morph_circuit_no = dilate:5 erode:6
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+****************************************************************************/
+int rzv2m_drp::setMorphologyParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch, uint16_t iterators,
+                uint16_t border_type, uint16_t border_value, uint16_t morph_circuit_no)
+{
+    int ret = 0;
+
+    /* set dst image size same as src size */
+    uint16_t dst_width = src_width;
+    uint16_t dst_height = src_height;
+    uint16_t dst_ch = src_ch;
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dst_width * dst_height * dst_ch;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*morph_circuit_no]);     // existence flag of circuit data
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*morph_circuit_no + 4]);       // address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*morph_circuit_no + 8]);       // size of resize circuit
+    
+    uint8_t drp_morphology_param[PARAM_SIZE_MORPHOLOGY];
+        
+    /* to write drp parameters to memory area */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next address to drp parameter
+    dst_adr = src_adr + src_size; // next address to input image
+    tmpl_adr = NULL;    //for 40bit addr
+    map_adr = NULL;
+
+    dst_adr_64aligment();
+
+    /* set morphology drp rapameter to local variables */
+    *((uint32_t *)(&drp_morphology_param[0]))  = src_adr;       //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_morphology_param[4]))  = dst_adr;       //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_morphology_param[8]))  = src_width;     //src width(pixel)
+    *((uint16_t *)(&drp_morphology_param[10])) = src_height;    //src height(pixel)
+    *((uint16_t *)(&drp_morphology_param[12])) = src_ch;        //reserved(0 fixed)
+    *((uint16_t *)(&drp_morphology_param[14])) = 0;             //reserved(0 fixed)
+    *((uint16_t *)(&drp_morphology_param[16])) = dst_width;     //dst width(pixel)
+    *((uint16_t *)(&drp_morphology_param[18])) = dst_height;    //dst width(pixel)
+    *((uint16_t *)(&drp_morphology_param[20])) = dst_ch;        //reserved(0 fixed)
+    *((uint16_t *)(&drp_morphology_param[22])) = 0;             //reserved(0 fixed)
+    memset( &drp_morphology_param[24],0,16);                    //Not used(0 fixed)
+    *((uint16_t *)(&drp_morphology_param[40])) = 0;             //CPU interrupt enable(0 fixed)
+    memset( &drp_morphology_param[42],0,6);                     //reserved(0 fixed)
+    *((uint16_t *)(&drp_morphology_param[48])) = iterators;     //iterators count         
+    *((uint16_t *)(&drp_morphology_param[50])) = border_type;   //bordertype
+    *((uint16_t *)(&drp_morphology_param[52])) = border_value;  //bordervalue
+    *((uint16_t *)(&drp_morphology_param[54])) = 0;             //reserved(0 fixed)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // assign pysical address
+    proc[DRPPARAM1].size = PARAM_SIZE_MORPHOLOGY;                          // gaussian parameter size
+    do
+        {
+            errno= 0;
+            ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]); // to access memory area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((0 != ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if (!((0 == ret) && (0 == errno)))
+        {
+            return DRP_PARAM_ERROR; 
+        }
+    do
+        {
+            errno= 0;
+            ret = write(fd_drp, drp_morphology_param, PARAM_SIZE_MORPHOLOGY); // to write parameter to assigned area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((-1 == ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if ( ret != PARAM_SIZE_MORPHOLOGY)
+        {
+            return DRP_PARAM_ERROR;   
+        }
+    
+    return DRP_NORMAL_END;
+}
+
+/***************************************************************************
+* Method Name   : setSobelParameter
+* Description   : to set Sobel parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, 
+                : src_ch = src channels number, deltaXY = deltax, deltay value type 
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+****************************************************************************/
+int rzv2m_drp::setSobelParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch, uint16_t delataXY)
+{
+    int ret = 0;
+    int circuit_no = PARAM_NO_SOBEL; // sobel circuit index
+    uint8_t drp_sobel_param[PARAM_SIZE_SOBEL]; 
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = src_size;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);    // existence flag of circuit data 
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);// address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);// size of resize circuit
+
+    /*  calculate address value of input image and output image */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next to DRP parameter area
+    dst_adr = src_adr + src_size;
+    tmpl_adr = NULL;    //for 40bit addr
+    map_adr = NULL;
+
+    dst_adr_64aligment();
+                                       
+    /* set sobel drp rapameter to local variables */
+    *((uint32_t *)(&drp_sobel_param[0]))  = src_adr;   //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_sobel_param[4]))  = dst_adr;   //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_sobel_param[8]))  = src_width; //input width(pixel)
+    *((uint16_t *)(&drp_sobel_param[10])) = src_height;//input height(pixel)
+    *((uint16_t *)(&drp_sobel_param[12])) = src_ch;    //input channels
+    *((uint16_t *)(&drp_sobel_param[14])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_sobel_param[16])) = src_width; //output width(pixel)
+    *((uint16_t *)(&drp_sobel_param[18])) = src_height;//output width(pixel)
+    *((uint16_t *)(&drp_sobel_param[20])) = src_ch;    //output channels
+    *((uint16_t *)(&drp_sobel_param[22])) = 0;         //reserved(0)
+    memset( &drp_sobel_param[24],0,16);                //Not used(0)
+    *((uint16_t *)(&drp_sobel_param[40])) = 0;         //CPU ionterupt on (0 fixed)
+    memset( &drp_sobel_param[42],0,6);                 //reserved(0 fixed)
+    *((uint16_t *)(&drp_sobel_param[48])) = delataXY;         //dx, dy
+    *((uint16_t *)(&drp_sobel_param[50])) = 0;         //reserved(0 fixed)
+    *((uint16_t *)(&drp_sobel_param[52])) = 0;         //reserved(0 fixed)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // pysical address 
+    proc[DRPPARAM1].size = PARAM_SIZE_SOBEL;// size of param (56 byte)
+                               
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]);   // to assign to drp area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    do
+    {
+        errno= 0;
+        ret = write(fd_drp, drp_sobel_param, PARAM_SIZE_SOBEL);  // to write parameter to specified address
+    } while ((-1 == ret) && (ERESTART == errno));
+        
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if ( ret != PARAM_SIZE_RESIZE)
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/***************************************************************************
+* Method Name   : setFilter2dParameter
+* Description   : to set Filter2d parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, 
+                  src_ch = src channels number, filter = filter values
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+****************************************************************************/
+int rzv2m_drp::setFilter2dParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch, float* filter)
+{
+    int ret = 0;
+    int circuit_no = PARAM_NO_FILTER2D; 
+
+    /* set dst image size same as src */
+    uint16_t dst_width = src_width;
+    uint16_t dst_height = src_height;
+    uint16_t dst_ch = src_ch;
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dst_width * dst_height * dst_ch;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);     // existence flag of circuit data
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);       // address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);       // size of resize circuit
+    
+    uint8_t drp_filter2d_param[PARAM_SIZE_FILTER2D];
+        
+    /* to write drp parameters to memory area */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next address to drp parameter
+    dst_adr = src_adr + src_size; // next address to input image
+    tmpl_adr = NULL;    //for 40bit addr
+    map_adr = NULL;
+
+    dst_adr_64aligment();
+
+    /* set filter2d drp rapameter to local variables */
+    *((uint32_t *)(&drp_filter2d_param[0]))  = src_adr;       //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_filter2d_param[4]))  = dst_adr;       //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_filter2d_param[8]))  = src_width;     //src width(pixel)
+    *((uint16_t *)(&drp_filter2d_param[10])) = src_height;    //src height(pixel)
+    *((uint16_t *)(&drp_filter2d_param[12])) = src_ch;        //src channel
+    *((uint16_t *)(&drp_filter2d_param[14])) = 0;             //reserved(0 fixed)
+    *((uint16_t *)(&drp_filter2d_param[16])) = dst_width;     //dst width(pixel)
+    *((uint16_t *)(&drp_filter2d_param[18])) = dst_height;    //dst width(pixel)
+    *((uint16_t *)(&drp_filter2d_param[20])) = dst_ch;        //dst channel
+    *((uint16_t *)(&drp_filter2d_param[22])) = 0;             //reserved(0 fixed)
+    memset( &drp_filter2d_param[24],0,16);                    //Not used(0 fixed)
+    *((uint16_t *)(&drp_filter2d_param[40])) = 0;             //CPU interrupt enable(0 fixed)
+    memset( &drp_filter2d_param[42],0,6);                     //reserved(0 fixed)
+
+    int param_idx = 48;
+
+    /* 3x3 kernel float value */
+    for(int cnt = 0; cnt < 9; cnt++)
+    {
+        *((float *)(&drp_filter2d_param[param_idx + (cnt * 4)])) = filter[cnt];
+    }
+
+    *((uint16_t *)(&drp_filter2d_param[84])) = 0;  //reserved(0 fixed)
+    *((uint16_t *)(&drp_filter2d_param[86])) = 0;  //reserved(0 fixed)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // assign pysical address
+    proc[DRPPARAM1].size = PARAM_SIZE_FILTER2D;                          // filter2d parameter size
+    do
+        {
+            errno= 0;
+            ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]); // to access memory area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((0 != ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if (!((0 == ret) && (0 == errno)))
+        { 
+            return DRP_PARAM_ERROR; 
+        }
+    do
+        {
+            errno= 0;
+            ret = write(fd_drp, drp_filter2d_param, PARAM_SIZE_FILTER2D); // to write parameter to assigned area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((-1 == ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if ( ret != PARAM_SIZE_FILTER2D)
+        {
+            return DRP_PARAM_ERROR;   
+        }
+
+    return DRP_NORMAL_END;
+}
+
+/***************************************************************************
+* Method Name   : setAdaptiveThreshold
+* Description   : to set AdaptiveThreshold parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, 
+                  src_ch = src channels number, max_value = max value condition is satisfied
+                  threshold_type = thresholding type, block_size = size of block size of pixel
+                  threshold_C = Constant substracted
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+****************************************************************************/
+int rzv2m_drp::setAdaptiveThreshold(uint16_t src_width, uint16_t src_height, uint16_t src_ch, uint16_t max_value, 
+                uint16_t threshold_type, uint32_t block_size, uint16_t threshold_C)
+{
+    int ret = 0;
+    int circuit_no = PARAM_NO_ATHRESHOLD; 
+
+    /* set dst image size same as src size */
+    uint16_t dst_width = src_width;
+    uint16_t dst_height = src_height;
+    uint16_t dst_ch = src_ch;
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dst_width * dst_height * dst_ch;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);     // existence flag of circuit data
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);       // address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);       // size of resize circuit
+    
+    uint8_t drp_athreshold_param[PARAM_SIZE_ATHRESHOLD];
+        
+    /* to write drp parameters to memory area */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next address to drp parameter
+    dst_adr = src_adr + src_size; // next address to input image
+    tmpl_adr = NULL;    //for 40bit addr
+    map_adr = NULL;
+
+    dst_adr_64aligment();
+
+    /* set adaptive threshold drp rapameter to local variables */
+    *((uint32_t *)(&drp_athreshold_param[0]))  = src_adr;       //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_athreshold_param[4]))  = dst_adr;       //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_athreshold_param[8]))  = src_width;     //src width(pixel)
+    *((uint16_t *)(&drp_athreshold_param[10])) = src_height;    //src height(pixel)
+    *((uint16_t *)(&drp_athreshold_param[12])) = 0;             //reserved(0 fixed)
+    *((uint16_t *)(&drp_athreshold_param[14])) = 0;             //reserved(0 fixed)
+    *((uint16_t *)(&drp_athreshold_param[16])) = dst_width;     //dst width(pixel)
+    *((uint16_t *)(&drp_athreshold_param[18])) = dst_height;    //dst width(pixel)
+    *((uint16_t *)(&drp_athreshold_param[20])) = 0;             //reserved(0 fixed)
+    *((uint16_t *)(&drp_athreshold_param[22])) = 0;             //reserved(0 fixed)
+    memset( &drp_athreshold_param[24],0,16);                    //Not used(0 fixed)
+    *((uint16_t *)(&drp_athreshold_param[40])) = 0;             //CPU interrupt enable(0 fixed)
+    memset( &drp_athreshold_param[42],0,6);                     //reserved(0 fixed)
+    *((uint16_t *)(&drp_athreshold_param[48])) = block_size;    //block size     
+    *((uint16_t *)(&drp_athreshold_param[50])) = max_value;     //max_value
+    *((uint16_t *)(&drp_athreshold_param[52])) = threshold_type;//threshold_type
+    *((uint16_t *)(&drp_athreshold_param[54])) = threshold_C;   //C
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // assign pysical address
+    proc[DRPPARAM1].size = PARAM_SIZE_ATHRESHOLD;                          // athreshold parameter size
+    do
+        {
+            errno= 0;
+            ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]); // to access memory area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((0 != ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if (!((0 == ret) && (0 == errno)))
+        {
+            return DRP_PARAM_ERROR; 
+        }
+    do
+        {
+            errno= 0;
+            ret = write(fd_drp, drp_athreshold_param, PARAM_SIZE_ATHRESHOLD); // to write parameter to assigned area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((-1 == ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if (ret != PARAM_SIZE_ATHRESHOLD)
+        {
+            return DRP_PARAM_ERROR;   
+        }
+        
+    return DRP_NORMAL_END;
+}
+
+/***************************************************************************
+* Method Name   : setMatchTemplateParameter
+* Description   : to set MatchTemplate parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, 
+                  src_ch = src channels number, templ_addr = template data address
+                  templ_width = template width, templ_height = template height
+                  method = matching method 
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+****************************************************************************/
+int rzv2m_drp::setMatchTemplateParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                    uint16_t tmpl_width, uint16_t tmpl_height, uint16_t tmpl_ch, uint16_t method)
+{
+    int ret = 0;
+
+    int circuit_no = PARAM_NO_MATCHTEMPLATE; 
+
+    /* set dst image for result */
+    uint16_t dst_width = src_width - tmpl_width + 1;
+    uint16_t dst_height = src_height - tmpl_height + 1;
+    uint16_t dst_ch = 1;
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dst_width * dst_height * dst_ch * 4; // 4 means 32 / 8 (depth)
+
+    tmpl_size = tmpl_width * tmpl_height * tmpl_ch;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);     // existence flag of circuit data
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);       // address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);       // size of resize circuit
+    
+    uint8_t drp_matchTempl_param[PARAM_SIZE_MATCHTEMPLATE];
+        
+    /* to write drp parameters to memory area */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next address to drp parameter
+    tmpl_adr = src_adr + src_size; // next address to template
+    map_adr = NULL;
+
+    tmpl_adr_64aligment();
+	
+    dst_adr = tmpl_adr + tmpl_size; // next address to input image
+
+    dst_adr_64aligment();
+
+    /* set match template drp rapameter to local variables */
+    *((uint32_t *)(&drp_matchTempl_param[0]))  = src_adr;       //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_matchTempl_param[4]))  = dst_adr;       //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_matchTempl_param[8]))  = src_width;     //src width(pixel)
+    *((uint16_t *)(&drp_matchTempl_param[10])) = src_height;    //src height(pixel)
+    *((uint16_t *)(&drp_matchTempl_param[12])) = src_ch;        //reserved(0 fixed)
+    *((uint16_t *)(&drp_matchTempl_param[14])) = 0;             //reserved(0 fixed)
+    *((uint16_t *)(&drp_matchTempl_param[16])) = 0;             //reserved(0 fixed)
+    *((uint16_t *)(&drp_matchTempl_param[18])) = 0;             //reserved(0 fixed)
+    *((uint16_t *)(&drp_matchTempl_param[20])) = 0;             //reserved(0 fixed)
+    *((uint16_t *)(&drp_matchTempl_param[22])) = 0;             //reserved(0 fixed)
+    memset( &drp_matchTempl_param[24],0,16);                    //Not used(0 fixed)
+    *((uint16_t *)(&drp_matchTempl_param[40])) = 0;             //CPU interrupt enable(0 fixed)
+    memset( &drp_matchTempl_param[42],0,6);                     //reserved(0 fixed)
+    *((uint32_t *)(&drp_matchTempl_param[48])) = tmpl_adr;    //template data address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_matchTempl_param[52])) = tmpl_width;   //template image width
+    *((uint16_t *)(&drp_matchTempl_param[54])) = tmpl_height;  //template image height
+    *((uint16_t *)(&drp_matchTempl_param[56])) = method;        //matching medthod
+    memset(&drp_matchTempl_param[58],0,6);                     //reserved(0 fixed)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // assign pysical address
+    proc[DRPPARAM1].size = PARAM_SIZE_MATCHTEMPLATE;                          // match template parameter size
+    do
+        {
+            errno= 0;
+            ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]); // to access memory area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((0 != ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if (!((0 == ret) && (0 == errno)))
+        {
+            return DRP_PARAM_ERROR; 
+        }
+    do
+        {
+            errno= 0;
+            ret = write(fd_drp, drp_matchTempl_param, PARAM_SIZE_MATCHTEMPLATE); // to write parameter to assigned area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((-1 == ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if (ret != PARAM_SIZE_MATCHTEMPLATE)
+        {
+            return DRP_PARAM_ERROR;   
+        }
+    
+    return DRP_NORMAL_END;
+}
+
+/*****************************************
+* Method Name   : setMatchTempl
+* Description   : to set match template image to drp input area
+* Arguments     : templData = template image data area
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_SRC_IMAGE_ERROR otherwise
+******************************************/
+ int rzv2m_drp::setMatchTempl(uint8_t *templData)
+ {
+    int ret = 0;
+
+    drp_data_t tmpl_img;
+    tmpl_img.address = tmpl_adr;          // physical memory address of input image area
+    tmpl_img.size = tmpl_size;            // input image size
+    
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &tmpl_img);
+    } while ((-1 == ret) && (ERESTART == errno));
+        
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_SRC_IMAGE_ERROR;
+    }
+
+    do
+    {
+         errno= 0;
+        ret = write(fd_drp, templData, tmpl_size);
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if ((uint32_t)ret != tmpl_size)
+    {
+        return DRP_SRC_IMAGE_ERROR;
+    }
+    
+    return DRP_NORMAL_END;
+ }
+
+/**************************************************************************************************************
+* Method Name   : setWarpAffineParameter
+* Description   : to set resize parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, src_ch = src image channels,
+                  dst_width = dst image width, dst_height = dst image height, toransform_matrix = toransformation matrix,
+                  border_value = border line color value
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+***************************************************************************************************************/
+int rzv2m_drp::setWarpAffineParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dst_width, uint16_t dst_height, float* transform_matrix, uint32_t border_value)
+{
+    int ret = 0;
+    int circuit_no = PARAM_NO_WARPAFFINE; // resize circuit index
+    uint8_t drp_warpaffine_param[PARAM_SIZE_WARPAFFINE];
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dst_width * dst_height * src_ch;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);    // existence flag of circuit data 
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);// address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);// size of resize circuit
+    
+    /*  calculate address value of input image and output image */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next to DRP parameter area
+    dst_adr = src_adr + src_size;
+    tmpl_adr = NULL;    //for 40bit addr
+    map_adr = NULL;
+    
+    dst_adr_64aligment();
+                            
+    /* set affine drp rapameter to local variables */
+    *((uint32_t *)(&drp_warpaffine_param[0]))  = src_adr;   //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_warpaffine_param[4]))  = dst_adr;   //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_warpaffine_param[8]))  = src_width; //input width(pixel)
+    *((uint16_t *)(&drp_warpaffine_param[10])) = src_height;//input height(pixel)
+    *((uint16_t *)(&drp_warpaffine_param[12])) = src_ch;    //input channels
+    *((uint16_t *)(&drp_warpaffine_param[14])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_warpaffine_param[16])) = dst_width; //output width(pixel)
+    *((uint16_t *)(&drp_warpaffine_param[18])) = dst_height;//output width(pixel)
+    *((uint16_t *)(&drp_warpaffine_param[20])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_warpaffine_param[22])) = 0;         //reserved(0)
+    memset(&drp_warpaffine_param[24],0,16);                 //Not used(0)
+    *((uint16_t *)(&drp_warpaffine_param[40])) = 0;         //CPU interupt on (0 fixed)   
+    memset(&drp_warpaffine_param[42],0,6);                  //reserved(0 fixed)
+    *((uint32_t *)(&drp_warpaffine_param[48])) = border_value;        //border_value is default o
+   
+    *((float *)(&drp_warpaffine_param[52])) = transform_matrix[0];    //transformation matrix
+    *((float *)(&drp_warpaffine_param[56])) = transform_matrix[1];    //transformation matrix
+    *((float *)(&drp_warpaffine_param[60])) = transform_matrix[2];    //transformation matrix
+    *((float *)(&drp_warpaffine_param[64])) = transform_matrix[3];    //transformation matrix
+    *((float *)(&drp_warpaffine_param[68])) = transform_matrix[4];    //transformation matrix
+    *((float *)(&drp_warpaffine_param[72])) = transform_matrix[5];    //transformation matrix
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // pysical address 
+    proc[DRPPARAM1].size = PARAM_SIZE_WARPAFFINE;// size of param (56 byte)
+                               
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]);   // to assign to drp area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    do
+    {
+        errno= 0;
+        ret = write(fd_drp, drp_warpaffine_param, PARAM_SIZE_WARPAFFINE);  // to write parameter to specified address
+    } while ((-1 == ret) && (ERESTART == errno));
+        
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (ret != PARAM_SIZE_WARPAFFINE)
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/**************************************************************************************************************
+* Method Name   : setPyrDownParameter
+* Description   : to set pyrDown() parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, src_ch = src image channels,
+                  dsize_width = output image width, dsize_height = output image height,
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+***************************************************************************************************************/
+int rzv2m_drp::setPyrDownParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dsize_width, uint16_t dsize_height)
+{
+    int ret = 0;
+    int circuit_no = PARAM_NO_PYRDOWN; // resize circuit index
+    uint8_t drp_pyrdown_param[PARAM_SIZE_PYRDOWN];
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dsize_width * dsize_height * src_ch;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);    // existence flag of circuit data 
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);// address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);// size of resize circuit
+    
+    /*  calculate address value of input image and output image */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next to DRP parameter area
+    dst_adr = src_adr + src_size;
+    tmpl_adr = NULL;    //for 40bit addr
+    map_adr = NULL;
+    
+    dst_adr_64aligment();
+                            
+    /* set pyrdown drp rapameter to local variables */
+    *((uint32_t *)(&drp_pyrdown_param[0]))  = src_adr;   //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_pyrdown_param[4]))  = dst_adr;   //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_pyrdown_param[8]))  = src_width; //input width(pixel)
+    *((uint16_t *)(&drp_pyrdown_param[10])) = src_height;//input height(pixel)
+    *((uint16_t *)(&drp_pyrdown_param[12])) = src_ch;    //input channels
+    *((uint16_t *)(&drp_pyrdown_param[14])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_pyrdown_param[16])) = dsize_width; //output width(pixel)
+    *((uint16_t *)(&drp_pyrdown_param[18])) = dsize_height;//output width(pixel)
+    *((uint16_t *)(&drp_pyrdown_param[20])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_pyrdown_param[22])) = 0;         //reserved(0)
+    memset(&drp_pyrdown_param[24],0,16);                 //Not used(0)
+    *((uint16_t *)(&drp_pyrdown_param[40])) = 0;         //CPU interupt on (0 fixed)   
+    memset(&drp_pyrdown_param[42],0,6);                  //reserved(0 fixed)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // pysical address 
+    proc[DRPPARAM1].size = PARAM_SIZE_PYRDOWN;// size of param (48 byte)
+                               
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]);   // to assign to drp area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    do
+    {
+        errno= 0;
+        ret = write(fd_drp, drp_pyrdown_param, PARAM_SIZE_PYRDOWN);  // to write parameter to specified address
+    } while ((-1 == ret) && (ERESTART == errno));
+        
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (ret != PARAM_SIZE_PYRDOWN)
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/**************************************************************************************************************
+* Method Name   : setPyrUpParameter
+* Description   : to set pyrUp() parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, src_ch = src image channels,
+                  dsize_width = output image width, dsize_height = output image height
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+***************************************************************************************************************/
+int rzv2m_drp::setPyrUpParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dsize_width, uint16_t dsize_height)
+{
+    int ret = 0;
+    int circuit_no = PARAM_NO_PYRUP; // resize circuit index
+    uint8_t drp_pyrup_param[PARAM_SIZE_PYRUP];
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dsize_width * dsize_height * src_ch;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);    // existence flag of circuit data 
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);// address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);// size of resize circuit
+    
+    /*  calculate address value of input image and output image */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next to DRP parameter area
+    dst_adr = src_adr + src_size;
+    tmpl_adr = NULL;    //for 40bit addr
+    map_adr = NULL;
+    
+    dst_adr_64aligment();
+                            
+    /* set pyrup drp rapameter to local variables */
+    *((uint32_t *)(&drp_pyrup_param[0]))  = src_adr;   //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_pyrup_param[4]))  = dst_adr;   //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_pyrup_param[8]))  = src_width; //input width(pixel)
+    *((uint16_t *)(&drp_pyrup_param[10])) = src_height;//input height(pixel)
+    *((uint16_t *)(&drp_pyrup_param[12])) = src_ch;    //input channels
+    *((uint16_t *)(&drp_pyrup_param[14])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_pyrup_param[16])) = dsize_width; //output width(pixel)
+    *((uint16_t *)(&drp_pyrup_param[18])) = dsize_height;//output width(pixel)
+    *((uint16_t *)(&drp_pyrup_param[20])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_pyrup_param[22])) = 0;         //reserved(0)
+    memset(&drp_pyrup_param[24],0,16);                 //Not used(0)
+    *((uint16_t *)(&drp_pyrup_param[40])) = 0;         //CPU interupt on (0 fixed)   
+    memset(&drp_pyrup_param[42],0,6);                  //reserved(0 fixed)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // pysical address 
+    proc[DRPPARAM1].size = PARAM_SIZE_PYRUP;// size of param (48 byte)
+                               
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]);   // to assign to drp area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    do
+    {
+        errno= 0;
+        ret = write(fd_drp, drp_pyrup_param, PARAM_SIZE_PYRUP);  // to write parameter to specified address
+    } while ((-1 == ret) && (ERESTART == errno));
+        
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (ret != PARAM_SIZE_PYRUP)
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/**************************************************************************************************************
+* Method Name   : setWarpPerspectiveParameter
+* Description   : to set warpPerspective() parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, src_ch = src image channels,
+                  dst_width = output image width, dst_height = output image height,
+                  toransform_matrix = toransformation matrix(3x3), border_value = border line color value
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+***************************************************************************************************************/
+int rzv2m_drp::setWarpPerspectiveParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dst_width, uint16_t dst_height, float* transform_matrix, uint32_t border_value)
+{
+    int ret = 0;
+    int circuit_no = PARAM_NO_WARPPERSPECTIVE; // resize circuit index
+    uint8_t drp_perspective_param[PARAM_SIZE_WARPPERSPECTIVE];
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dst_width * dst_height * src_ch;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);    // existence flag of circuit data 
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);// address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);// size of resize circuit
+    
+    /*  calculate address value of input image and output image */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next to DRP parameter area
+    dst_adr = src_adr + src_size;
+    tmpl_adr = NULL;    //for 40bit addr
+    map_adr = NULL;
+    
+    dst_adr_64aligment();
+                            
+    /* set perspective drp rapameter to local variables */
+    *((uint32_t *)(&drp_perspective_param[0]))  = src_adr;   //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_perspective_param[4]))  = dst_adr;   //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_perspective_param[8]))  = src_width; //input width(pixel)
+    *((uint16_t *)(&drp_perspective_param[10])) = src_height;//input height(pixel)
+    *((uint16_t *)(&drp_perspective_param[12])) = src_ch;    //input channels
+    *((uint16_t *)(&drp_perspective_param[14])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_perspective_param[16])) = dst_width; //output width(pixel)
+    *((uint16_t *)(&drp_perspective_param[18])) = dst_height;//output width(pixel)
+    *((uint16_t *)(&drp_perspective_param[20])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_perspective_param[22])) = 0;         //reserved(0)
+    memset(&drp_perspective_param[24],0,16);                 //Not used(0)
+    *((uint16_t *)(&drp_perspective_param[40])) = 0;         //CPU interupt on (0 fixed)   
+    memset(&drp_perspective_param[42],0,6);                  //reserved(0 fixed)
+    *((uint32_t *)(&drp_perspective_param[48])) = border_value;        //border_value
+   
+    int param_idx = 52;
+    for(int idx = 0; idx<9; idx++) // 9 elements
+    {
+        *((float *)(&drp_perspective_param[param_idx])) = transform_matrix[idx]; //transformation matrix
+        param_idx += 4;
+    }
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // pysical address 
+    proc[DRPPARAM1].size = PARAM_SIZE_WARPPERSPECTIVE;// size of param (56 byte)
+                               
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]);   // to assign to drp area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    do
+    {
+        errno= 0;
+        ret = write(fd_drp, drp_perspective_param, PARAM_SIZE_WARPPERSPECTIVE);  // to write parameter to specified address
+    } while ((-1 == ret) && (ERESTART == errno));
+        
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (ret != PARAM_SIZE_WARPPERSPECTIVE)
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/**************************************************************************************************************
+* Method Name   : setFastParameter
+* Description   : to set FAST parameter to drp
+* Arguments     : src_width = src image width,
+                  src_height = src image height,
+                  src_ch = src image channels,
+                  threshold = threshold
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+***************************************************************************************************************/
+int rzv2m_drp::setFastParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch, uint16_t threshold)
+{
+    int ret = 0;
+    int circuit_no = PARAM_NO_FAST; // FAST circuit index
+    uint8_t drp_fast_param[PARAM_SIZE_FAST];
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = (src_width + 2) * (src_height + 2) / 9 * 64;   //MAX dst size:(3842x2162*64)/9 = about 56.3MByte
+
+    possiblef = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32 * circuit_no]);        // existence flag of circuit data
+    drp_position = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32 * circuit_no + 4]); // address at circuit data (offset value from CONFIG_BASE)
+    drp_size = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32 * circuit_no + 8]);     // size of FAST circuit
+
+    /*  calculate address value of input image and output image */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE; // next to DRP parameter area
+    dst_adr = src_adr + src_size;
+    tmpl_adr = NULL;    //for 40bit addr
+    map_adr = NULL;
+ 
+    dst_adr_64aligment();
+
+    /* set FAST drp rapameter to local variables */
+    *((uint32_t *)(&drp_fast_param[0]))  = src_adr;   //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_fast_param[4]))  = dst_adr;   //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_fast_param[8])) = src_width;   // input width (pixel)
+    *((uint16_t *)(&drp_fast_param[10])) = src_height; // input height (pixel)
+    *((uint16_t *)(&drp_fast_param[12])) = 1;          // input channels (1 fixed)
+    *((uint16_t *)(&drp_fast_param[14])) = 0;          // reserved (0 fixed)
+    *((uint16_t *)(&drp_fast_param[16])) = 0;          // reserved (0 fixed)
+    *((uint16_t *)(&drp_fast_param[18])) = 0;          // reserved (0 fixed)
+    *((uint16_t *)(&drp_fast_param[20])) = 0;          // reserved (0 fixed)
+    *((uint16_t *)(&drp_fast_param[22])) = 0;          // reserved (0 fixed)
+    memset(&drp_fast_param[24], 0, 16);                // Not used (0 fixed)
+    *((uint16_t *)(&drp_fast_param[40])) = 0;          // CPU ionterupt on (0 fixed)
+    memset(&drp_fast_param[42], 0, 6);                 // reserved (0 fixed)
+    *((uint16_t *)(&drp_fast_param[48])) = threshold;  // threshold
+    *((uint16_t *)(&drp_fast_param[50])) = 0x00FF;     // reserved (0x00FF fixed)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy + opencv_bin_param_base; // pysical address
+    proc[DRPPARAM1].size = PARAM_SIZE_FAST;                                  // size of param (56 byte)
+
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]); // to assign to drp area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        fprintf(stderr, "[ERROR] Failed to assign DRP parameter11111\n");
+
+        return DRP_PARAM_ERROR;
+    }
+
+    do
+    {
+        errno = 0;
+        ret = write(fd_drp, drp_fast_param, PARAM_SIZE_FAST); // to write parameter to specified address
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (ret != PARAM_SIZE_FAST)
+    {
+        fprintf(stderr, "[ERROR] Failed to write DRP parameter\n");
+        return DRP_PARAM_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/**************************************************************************************************************
+* Method Name   : setRemapParameter
+* Description   : to set REMAP parameter to drp
+* Arguments     : src_width    = src image width,
+                  src_height   = src image height,
+                  src_ch       = src image channels,
+                  dst_width    = dst image width,
+                  dst_height   = dst image height,
+                  border_color = color
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+***************************************************************************************************************/
+int rzv2m_drp::setRemapParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dst_width, uint16_t dst_height, uint32_t border_color)
+{
+    int ret = 0;
+    int circuit_no = PARAM_NO_REMAP; // REMAP circuit index
+    uint8_t drp_remap_param[PARAM_SIZE_REMAP];
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dst_width * dst_height * src_ch;
+
+    map_size = dst_width * dst_height * sizeof(float) * 2;
+
+    possiblef    = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32 * circuit_no]);     // existence flag of circuit data
+    drp_position = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32 * circuit_no + 4]); // address at circuit data (offset value from CONFIG_BASE)
+    drp_size     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32 * circuit_no + 8]); // size of REMAP circuit
+
+    /*  calculate address value of input image and output image */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE; // next to DRP parameter area
+
+    dst_adr = src_adr + src_size;
+    tmpl_adr = NULL;    //for 40bit addr
+
+    dst_adr_64aligment();
+
+    map_adr = dst_adr + dst_size;
+
+    map_adr_64aligment();
+
+    /* set REMAP drp rapameter to local variables */
+    *((uint32_t *)(&drp_remap_param[0]))  = src_adr;      // src image address
+    *((uint32_t *)(&drp_remap_param[4]))  = dst_adr;      // dst image address
+    *((uint16_t *)(&drp_remap_param[8]))  = src_width;    // input width (pixel)
+    *((uint16_t *)(&drp_remap_param[10])) = src_height;   // input height (pixel)
+    *((uint16_t *)(&drp_remap_param[12])) = src_ch;       // input channels (1 fixed)
+    *((uint16_t *)(&drp_remap_param[14])) = 0;            // reserved (0 fixed)
+    *((uint16_t *)(&drp_remap_param[16])) = dst_width;    // output width (pixel)
+    *((uint16_t *)(&drp_remap_param[18])) = dst_height;   // output height (pixel)
+    *((uint16_t *)(&drp_remap_param[20])) = 0;            // reserved (0 fixed)
+    *((uint16_t *)(&drp_remap_param[22])) = 0;            // reserved (0 fixed)
+    memset(&drp_remap_param[24], 0, 16);                  // sync set
+    *((uint16_t *)(&drp_remap_param[40])) = 0;            // CPU ionterupt on (0 fixed)
+    memset(&drp_remap_param[42], 0, 6);                   // reserved (0 fixed)
+    *((uint32_t *)(&drp_remap_param[48])) = map_adr;      // map address
+    *((uint32_t *)(&drp_remap_param[50])) = border_color; // color
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy + opencv_bin_param_base; // pysical address
+    proc[DRPPARAM1].size = PARAM_SIZE_REMAP;                                  // size of param (56 byte)
+
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]); // to assign to drp area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        fprintf(stderr, "[ERROR] Failed to assign DRP parameter11111\n");
+
+        return DRP_PARAM_ERROR;
+    }
+
+    do
+    {
+        errno = 0;
+        ret = write(fd_drp, drp_remap_param, PARAM_SIZE_REMAP); // to write parameter to specified address
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (ret != PARAM_SIZE_REMAP)
+    {
+        fprintf(stderr, "[ERROR] Failed to write DRP parameter\n");
+        return DRP_PARAM_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/*****************************************
+* Method Name   : setMapData
+* Description   : to set map data to drp input area
+* Arguments     : mapData = map data area
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_SRC_IMAGE_ERROR otherwise
+******************************************/
+ int rzv2m_drp::setMapData(uint8_t *mapData)
+ {
+    int ret = 0;
+
+    drp_data_t map_data;
+    map_data.address = map_adr;          // physical memory address of input map area
+    map_data.size = map_size;            // input map size
+
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &map_data);
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_SRC_IMAGE_ERROR;
+    }
+
+    do
+    {
+        errno= 0;
+        ret = write(fd_drp, mapData, map_size);
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if ((uint32_t)ret != map_size)
+    {
+        return DRP_SRC_IMAGE_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+ }
+
+/*****************************************
+* Method Name   : setSrcImage
+* Description   : to set src image to drp input area
+* Arguments     : img-_buffer = src image data area
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_SRC_IMAGE_ERROR otherwise
+******************************************/
+int rzv2m_drp::setSrcImage(uint8_t *img_buffer)
+{
+    int ret = 0;
+
+    drp_data_t src_img;
+    src_img.address = src_adr;          // physical memory address of input image area
+    src_img.size = src_size;            // input image size
+    
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &src_img);
+    } while ((-1 == ret) && (ERESTART == errno));
+        
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_SRC_IMAGE_ERROR;
+    }
+
+    do
+    {
+        errno= 0;
+        ret = write(fd_drp, img_buffer, src_size);
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if ((uint32_t)ret != src_size)
+    {
+        return DRP_SRC_IMAGE_ERROR;
+    }
+    
+    return DRP_NORMAL_END;
+}
+
+/*****************************************
+* Method Name   : execDRP
+* Description   : executing drp process
+* Arguments     : void
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_EXEC_ERROR otherwise
+******************************************/
+int rzv2m_drp::execDRP(void)
+{
+    int ret = 0;
+    drp_seq_t seq;
+  
+    /* to write drp parameters to memory area */
+    proc[DRPCFG1].address = opencv_bin_addr64_phy + opencv_bin_config_base + drp_position;  // pysical address
+    proc[DRPCFG1].size    = drp_size;                                               // data size
+
+    seq.num         = DRPCFG_NUM;
+
+#ifdef DEV_RZV2H   // for 40bit addr
+    seq.order[0]    = DRP_EXE_DRP_40BIT;
+#else
+    seq.order[0]    = DRP_EXE_DRP;
+#endif
+    seq.address     = opencv_bin_addr64_phy + opencv_bin_descriptor_base;           // descriptor base
+
+#ifdef DEV_RZV2H  // for 40bit addr
+    seq.iodata[0].address = src_adr;
+    seq.iodata[0].size    = src_size;
+    seq.iodata[0].pos     = 0;
+    seq.iodata[1].address = dst_adr;
+    seq.iodata[1].size    = dst_size;
+    seq.iodata[1].pos     = 4;
+    
+    if( ( tmpl_adr == NULL ) && ( map_adr == NULL ) )
+    {
+        seq.iodata_num          = 2;
+    }
+    else if( tmpl_adr != NULL )
+    {
+        seq.iodata_num          = 3;    //Template matching
+        seq.iodata[2].address   = tmpl_adr;
+        seq.iodata[2].size      = tmpl_size;
+        seq.iodata[2].pos       = 48;
+    }
+    else if( map_adr != NULL )
+    {
+        seq.iodata_num          = 3;    //Remap
+        seq.iodata[2].address   = map_adr;
+        seq.iodata[2].size      = map_size;
+        seq.iodata[2].pos       = 48;
+    }
+    
+#endif
+    
+    ret = ioctl(fd_drp, DRP_SET_SEQ, &seq);                                         // to set seq data
+
+    if ((0 != ret) && (EBUSY == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (0 != ret || (0 != errno) )
+    {
+        return DRP_EXEC_ERROR;
+    }
+
+    /* to start drp process */  
+    ret = ioctl(fd_drp, DRP_START, proc);
+
+    if ((0 != ret) && (EBUSY == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (0 != ret || (0 != errno) )
+    {
+        return DRP_EXEC_ERROR;
+    }
+    
+    /* waiting finish */
+    
+    fd_set rfds;
+    FD_ZERO(&rfds);
+    FD_SET(fd_drp, &rfds);
+    struct timeval tv;
+    tv.tv_sec = DRP_EXEC_TIMEOUT_SECONDS;
+    tv.tv_usec = 0;
+
+    ret = select(fd_drp + 1, &rfds, NULL, NULL, &tv);
+
+    if (0 == ret)
+    {
+        return DRP_EXEC_ERROR;
+    }
+    else if (-1 == ret)
+    {
+        return DRP_EXEC_ERROR;
+    }
+
+    /* to check result */
+    
+    drp_status_t drp_status;
+    ret = ioctl(fd_drp, DRP_GET_STATUS, &drp_status);
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!(((0 == ret) || (EBUSY == errno)) && (0 == drp_status.err)))
+    {
+        return DRP_EXEC_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/*****************************************
+* Method Name   : readTemplaeMatchResult
+* Description   : to read dst image from drp output area
+* Arguments     : dst_img_buffer = dst image buffer 
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_DST_IMAGE_ERROR otherwise
+******************************************/
+int rzv2m_drp::readTemplateMatchResult(uint8_t *dst_image_buffer)
+{
+    int ret = 0;
+
+    drp_data_t dst_img;
+    dst_img.address = dst_adr;    // pysical address to dst image data
+    dst_img.size = dst_size;      // dst image size
+
+    do
+    {
+        errno= 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &dst_img); // assign to DRP memory area
+    } while ((-1 == ret) && (ERESTART == errno));
+        
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_DST_IMAGE_ERROR;
+    }
+
+    {
+        errno= 0;
+        ret = read(fd_drp, dst_image_buffer, dst_size);   // to read dst image from specified address
+    } while ((-1 == ret) && (ERESTART == errno));
+    
+    if ((-1 == ret) && (EACCES == errno))
+    {
+         conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (dst_size != (uint32_t)ret)
+    {
+        return DRP_DST_IMAGE_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/*****************************************
+* Method Name   : dst_adr_64aligment()
+* Description   : calc 64 bit aligment address
+* Arguments     : none
+* Return value  : void
+******************************************/
+void rzv2m_drp::dst_adr_64aligment()
+{
+    /* 64bit aligment */
+    uint32_t align = 0;
+
+    align = 64 - (dst_adr % 64);
+    dst_adr = dst_adr + align; 
+
+    return;
+}
+
+/*****************************************
+* Method Name   : tmpl_adr_64aligment()
+* Description   : calc 64 bit aligment address
+* Arguments     : none
+* Return value  : void
+******************************************/
+void rzv2m_drp::tmpl_adr_64aligment()
+{
+    /* 64bit aligment */
+    uint32_t align = 0;
+
+    align = 64 - (tmpl_adr % 64);
+    tmpl_adr = tmpl_adr + align; 
+
+    return;
+}
+
+/*****************************************
+* Method Name   : map_adr_64aligment()
+* Description   : calc 64 bit aligment address
+* Arguments     : none
+* Return value  : void
+******************************************/
+void rzv2m_drp::map_adr_64aligment()
+{
+    /* 64bit aligment */
+    uint32_t align = 0;
+
+    align = 64 - (map_adr % 64);
+    map_adr = map_adr + align; 
+
+    return;
+}
+
+/*****************************************
+* Method Name   : readDstImage
+* Description   : to read dst image from drp output area
+* Arguments     : img_buffer = dst image buffer 
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_DST_IMAGE_ERROR otherwise
+******************************************/
+int rzv2m_drp::readDstImage(uint8_t *dst_image_buffer)
+{
+    int ret = 0;
+    drp_data_t dst_img;
+
+    dst_img.address = dst_adr;    // pysical address to dst image data
+    dst_img.size = dst_size;      // dst image size
+
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &dst_img); // assign to DRP memory area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_DST_IMAGE_ERROR;
+    }
+
+    {
+        errno = 0;
+        ret = read(fd_drp, dst_image_buffer, dst_size); // to read dst image from specified address
+    }
+    while ((-1 == ret) && (ERESTART == errno))
+        ;
+
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (dst_size != (uint32_t)ret)
+    {
+        return DRP_DST_IMAGE_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/*****************************************
+ * Method Name   : readCornerPoints
+ * Description   : Read corner points and their scores from drp output area
+ * Arguments     : std::vector<cv::KeyPoint> &keypoints
+ * Return value  : DRP_NORMAL_END if succeeded
+ *                 DRP_DST_IMAGE_ERROR otherwise
+ ******************************************/
+int rzv2m_drp::readCornerPoints(std::vector<cv::KeyPoint> &keypoints)
+{
+    /*
+    This function sends the FAST result on DRP to CPU.
+    To do that, we first obtain the number of corners, which deterimines the buffer size for FAST corners, from DRP memory.
+    Then we copy FAST corners and their scores into the buffer whose size is given by,
+    64 bit + 64 bit * number of corners,
+    the 1st conponent stands for the baffer size of the number of corners and 0-padding region, and the 2nd does for that of corners and their scores.
+    In other words, we copy both number of corners and each FAST corner information into the buffer.
+    Finally, we send FAST corners and their scores in the buffer to Keypoints list on CPU with rearrangement.
+    */
+    // 1. Number of corners
+    int ret = 0;
+    drp_data_t dst_corner;
+
+    dst_corner.address = dst_adr; // pysical address to dst corner data
+    dst_corner.size = 8;          // buffer size for number of corners (64 bit = number of corners and 0-padding region)
+
+    uint32_t out_count_buffer[2]; // 0-th component is corner number (32 bit) and  1st one is 0-padding region (32 bit)
+
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &dst_corner); // assign to DRP memory area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_DST_IMAGE_ERROR;
+    }
+
+    {
+        errno = 0;
+        ret = read(fd_drp, out_count_buffer, dst_corner.size); // read number of corners from specified address
+    } 
+    while((-1 == ret) && (ERESTART == errno));
+        
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (dst_corner.size != (uint32_t)ret)
+    {
+        return DRP_DST_IMAGE_ERROR;
+    }
+
+    int count = out_count_buffer[0]; // Number of corners
+
+    if (count == 0)
+    {
+        return DRP_NORMAL_END;
+    }
+
+    // 2. Keypoints and their scores
+    ret = 0;
+
+    dst_corner.size = 8 * (count + 1); // 64 bit (coner number + zero-padding) + 64 bit * nubmer of corners
+
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &dst_corner); // assign to DRP memory area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_DST_IMAGE_ERROR;
+    }
+
+    /*
+    Buffer for corners
+    0th component: X coordinate (16 bit)
+    1st component: Y coordinate (16 bit)
+    2nd conponent: Score  (16 bit)
+    3rd component: 0-padding (16 bit)
+    */
+    uint16_t out_corner_buffer[4 * FAST_READ_BUFFER_SIZE];
+
+    int read_size;
+    int read_residual = count;
+
+    // Copy into Keypoint list
+    keypoints.clear();                  // Initialization
+    cv::KeyPoint kpt(0, 0, 7.f, -1, 0); // Define the same format as cv::KeyPoint in CPU case (see definition in hal_FAST)
+
+    for (int idx = 0; read_residual > 0; idx++)
+    {
+        if (read_residual >= FAST_READ_BUFFER_SIZE)
+        {
+            read_size = FAST_READ_BUFFER_SIZE;
+        }
+        else
+        {
+            read_size = read_residual;
+            if (idx == 0)
+            {
+                read_size = read_size + 1;
+            }
+        }
+
+    {
+        errno= 0;
+            ret = read(fd_drp, &out_corner_buffer[0], sizeof(uint16_t) * 4 * read_size); // read corners from specified address
+    }
+    while((-1 == ret) && (ERESTART == errno));
+
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+        if (sizeof(uint16_t) * 4 * read_size != (uint32_t)ret)
+    {
+        return DRP_DST_IMAGE_ERROR;
+    }
+
+        // Add result to kypoint from buffer
+        // 0th component of count corresponds to corner number and 0-padding region and
+        // i-th component (i = 1, 2, 3, ...) does to i-th corner and score.
+        int i_kpt = 0;
+        if (idx == 0)
+        {
+            i_kpt = 1;
+        }
+
+        for (i_kpt; i_kpt < read_size; i_kpt++)
+        {
+            // X coordinate
+            kpt.pt.x = (float)out_corner_buffer[0 + (i_kpt * 4)];
+
+            // Y coordinate
+            kpt.pt.y = (float)out_corner_buffer[1 + (i_kpt * 4)];
+
+            // Score
+            kpt.response = (float)out_corner_buffer[2 + (i_kpt * 4)];
+
+            // add result (corner position and its score) to keypoints list
+            keypoints.push_back(kpt);
+        }
+
+        read_residual = read_residual - read_size;
+
+        if ((idx == 0) && (read_residual > 0))
+        {
+            read_residual = read_residual + 1;
+        }
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/*****************************************
+* Method Name   : DRP_sem_open(void)
+* Description   : Open DRP semaphore
+* Arguments     :  
+* Return value  : =0:reset ok, <0: reset error 
+******************************************/
+static int DRP_sem_open(void)
+{
+    int ret = 0;
+
+    while (1 == g_initializing)
+    {
+        usleep(100);   /* 0.1 msec */
+    }
+    if ((NULL != g_sem) && (SEM_FAILED != g_sem))
+    {
+        /* Already opened */
+        return 0;
+    }
+    g_initializing = 1;
+
+    errno = 0;
+    g_sem = sem_open(SHM_SEMAPHORE_PATH, O_RDWR | O_CREAT | O_EXCL, 0660, 1);
+    if (EEXIST == errno)
+    {
+        CV_LOG_INFO(nullptr, "DRP_sem is already exists. Open Created sem.");
+        waiting_count = 0;
+        g_sem = sem_open(SHM_SEMAPHORE_PATH, O_RDWR);
+    }
+    else if (SEM_FAILED == g_sem)
+    {
+        CV_LOG_INFO(nullptr, "failed to open DRP semaphore file");
+        g_sem = NULL;
+        ret = -1;
+    }
+
+    if (0 != ret)
+    {
+        CV_LOG_INFO(nullptr, "Failed in DRP_sem_open");
+    }
+    g_initializing = 0;
+    return ret;
+}
+
+/*****************************************
+* Method Name   : DRP_sem_close(void)
+* Description   : Close DRP semaphore
+* Arguments     :  
+* Return value  : =0:reset ok, <0: reset error 
+******************************************/
+static int DRP_sem_close(void)
+{
+    CV_LOG_INFO(nullptr, "DRP_sem_close start.");
+    int ret = 0;
+
+    if (1 == g_initializing)
+    {
+        usleep(100);   /* 0.1 msec */
+    }
+
+    if ((NULL == g_sem) || (SEM_FAILED == g_sem))
+    {
+        /* sem is not existed */
+        return 0;
+    }
+    g_initializing = 1;
+    
+    ret = sem_close(g_sem);
+    if (0 != ret)
+    {
+        CV_LOG_INFO(nullptr,"Failed in DRP_sem_close");
+    }
+    g_sem = NULL;
+    g_initializing = 0;
+    waiting_count = 0;
+
+    return ret;
+}
+
+/*****************************************
+* Method Name   : DRP_sem_post(void)
+* Description   : Post DRP semaphore
+* Arguments     :  
+* Return value  : =0:reset ok, <0: reset error 
+******************************************/
+static int DRP_sem_post(void)
+{
+    int sval = -1;
+    int ret;
+
+    waiting_count --;
+
+    CV_LOG_INFO(nullptr,"DRP_sem_post start");
+    CV_LOG_INFO(nullptr, "DRP_sem_post in DRP_sem_open start.");
+    ret = DRP_sem_open();
+    if (0 != ret)
+    {
+        return ret;
+    }
+    ret = sem_getvalue(g_sem, &sval);
+    if (0 != ret)
+    {
+        CV_LOG_INFO(nullptr, "try sem_post, but sem is invalid.");
+        return -1;
+    }
+    /* sem value must be 0 or 1 */
+    if (0 >= sval)
+    {
+        CV_LOG_INFO(nullptr, "sem_post start. wating threads = " << waiting_count);
+        return sem_post(g_sem);
+    }
+    return 0;
+}
+
+/*****************************************
+* Method Name   : DRP_sem_wait(void)
+* Description   : Wait DRP semaphore
+* Arguments     :  
+* Return value  : =0:reset ok, <0: reset error 
+******************************************/
+static int DRP_sem_wait(void)
+{
+    int ret;
+    struct timespec timeout;
+    
+    CV_LOG_INFO(nullptr, "DRP_sem_wait start");
+    CV_LOG_INFO(nullptr, "DRP_sem_wait in DRP_sem_open start.")
+    ret = DRP_sem_open();
+    if (0 != ret)
+    {
+        return ret;
+    }
+
+    clock_gettime(CLOCK_REALTIME, &timeout);
+    timeout.tv_sec += SEM_TIMEOUT_SEC;
+    timeout.tv_nsec += SEM_TIMEOUT_NSEC;
+    if (1e9 < timeout.tv_nsec)
+    {
+        timeout.tv_sec += 1;
+        timeout.tv_nsec -= 1e9;
+    }
+
+    errno = 0;
+
+    CV_LOG_INFO(nullptr, "sem_timedwait start. waiting threads =" << waiting_count);
+    waiting_count ++;
+
+    ret = sem_timedwait(g_sem, &timeout);
+    if (ETIMEDOUT == errno)
+    {
+        CV_LOG_INFO(nullptr, "DRP semaphore is locked too long time, so unlock and try to lock again.");
+        /* try again with sem_post */
+        ret = DRP_sem_post();
+        if (0 == ret)
+        {
+            ret = DRP_sem_wait();
+        }
+        else
+        {
+            CV_LOG_INFO(nullptr, "Failed to unlock DRP semaphore.");
+        }
+    }
+
+    if (0 != ret)
+    {
+        CV_LOG_INFO(nullptr, "Failed in sem_waite");
+    }
+
+    return ret;
+}
+
+/*****************************************
+* Method Name   : set_drp_end()
+* Description   : reset to OpenCVA inprocess
+* Arguments     :  
+* Return value  : =0:reset ok, <0: reset error 
+******************************************/
+int rzv2m_drp::set_drp_end()
+{
+#if 0
+    struct drp_proces_thread_id drp_proc_info;
+    int ret_ioctl = 0;
+    
+    drp_proc_info.process_id = process_id;
+    drp_proc_info.thread_id = thread_id;
+
+    ret_ioctl = ioctl(fd_drv, IO_CTL_DRP_END, &drp_proc_info);
+
+    if (ret_ioctl < 0)
+    {
+        return DRP_CONFLICT_ERROR;
+    }
+
+    if (ret_ioctl == 0)
+    {
+        CV_LOG_INFO(nullptr, "drp in process reset.");
+    }
+#endif
+
+    DRP_sem_post();
+
+    if(waiting_count <= 0)
+    {
+        DRP_sem_close();
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/*****************************************
+* Method Name   : set_drp_start()
+* Description   : set to OpenCVA inprocess
+* Arguments     :  
+* Return value  : =0:set ok, <0: set error 
+******************************************/
+int rzv2m_drp::set_drp_start()
+{
+#if 0
+    struct drp_proces_thread_id drp_proc_info;
+    pid_t pid;
+	std::stringstream str_strm;
+    int ret_ioctl = 0;
+
+	pid = getpid(); 
+	process_id = (uint32_t)pid;
+
+    str_strm << std::this_thread::get_id();
+    thread_id = std::stoul(str_strm.str());
+    
+    drp_proc_info.process_id = process_id;
+    drp_proc_info.thread_id = thread_id;
+
+    ret_ioctl = ioctl(fd_drv, IO_CTL_DRP_START, &drp_proc_info);
+
+    if (ret_ioctl == IO_CTL_DRP_CONFLICT)
+    {
+        conflict_action_exec();
+        return DRP_CONFLICT_ERROR;
+    }
+
+    if (ret_ioctl == 0)
+    {
+        CV_LOG_INFO(nullptr, "drp in process set.");
+    }
+#endif
+
+    int ret_sem = 0;
+
+    // DRP_sem_wait in DRP_sem_open.
+    ret_sem = DRP_sem_wait();
+    if (0 != ret_sem)
+    {
+        CV_LOG_INFO(nullptr, "DRP_sem_wait error.");
+        // Return this error code as the calling DRP execution function determines 
+        // that execution is not possible due to DRP_CONFLICT_ERROR.
+        return DRP_CONFLICT_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/*****************************************
+* Method Name   : initialize
+* Description   : initializing device driver 
+* Arguments     : void  
+* Return value  : void
+******************************************/
+void rzv2m_drp::initialize(void)
+{
+    fd_drv = 0;
+    int ret = 0;
+    drp_data_t local_drp_data;
+
+#if 0
+    /* opencva driver open */
+    if ((fd_drv = open(DRV_DEV_NAME, O_RDWR)) < 0) 
+    {
+        return;
+    }
+#endif
+
+#if 0
+    /* to read 32bit physical address */
+    if (ioctl(fd_drv, 0, &opencv_bin_addr32_phy) < 0)
+    {
+        return;
+    } 
+#endif
+
+    /* to open DRP(B) driver */
+    fd_drp = open(DRP_DEV_NAME, O_RDWR);
+    if (0 > fd_drp)
+    {
+        return;
+    }
+
+    /* to read 64bit physical address from DRP driver */
+    if (ioctl(fd_drp, DRP_GET_OPENCVA_AREA, &local_drp_data) < 0)
+    {
+        return;
+    } 
+    opencv_bin_addr64_phy = local_drp_data.address;
+
+    /* read opencva binary data */
+    drp_data_t opencvbin;
+    uint32_t bin_size = OCA_BIN_SIZE;
+
+    opencvbin.address = opencv_bin_addr64_phy;           
+    opencvbin.size = bin_size;                            
+    
+    do
+    {
+        /* assign */
+        errno= 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &opencvbin);
+    } while((-1 == (int)ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return;
+    }
+
+    if (!((0 == (int)ret) && (0 == errno)))
+    {
+        return;
+    }
+
+    do
+    {
+        errno= 0;
+        /* exec read */
+        ret = read(fd_drp, opencv_bin_p, bin_size);      
+    } while((-1 == (int)ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return;
+    }
+
+    if (ret != (int)bin_size)
+    {
+        return ;
+    }
+ 
+    /* reading opencv binary haeader part */
+    opencv_bin_signature_p      = (char *)(&opencv_bin_p[0]);           // pointer to signature(16byte)
+    opencv_bin_version_p        = (char *)(&opencv_bin_p[16]);          // pointer to version info(8byte)
+    opencv_bin_list_base        = *(uint32_t *)(&opencv_bin_p[24]);     // opencva list address(offset value)
+    opencv_bin_config_base      = *(uint32_t *)(&opencv_bin_p[28]);     // opencva circuit info address(offset value)
+    opencv_bin_descriptor_base  = *(uint32_t *)(&opencv_bin_p[32]);     // opencva descriptor info address(offset value)
+    opencv_bin_param_base       = *(uint32_t *)(&opencv_bin_p[36]);     // opencva parameter info address(offset value)
+
+    if(strcmp(opencv_bin_signature_p, OCABIN_SIGNATURE) != 0)
+    {
+        return;
+    }
+
+    if(memcmp(opencv_bin_version_p, OCABIN_MAJOR_VER, strlen(OCABIN_MAJOR_VER) ) != 0)
+    {
+        return;
+    }
+
+    /* set initialized complete */
+    initialized = true;
+
+    return;
+}
+
+/*****************************************
+* Method Name   : ~rzv2m_drp
+* Description   : Destructor
+******************************************/
+rzv2m_drp::~rzv2m_drp()
+{
+    close(fd_drp);
+}
\ No newline at end of file
diff --git a/modules/imgproc/src/smooth.dispatch.cpp b/modules/imgproc/src/smooth.dispatch.cpp
index 8a521d6..397acdf 100644
--- a/modules/imgproc/src/smooth.dispatch.cpp
+++ b/modules/imgproc/src/smooth.dispatch.cpp
@@ -54,6 +54,7 @@
 #include "opencl_kernels_imgproc.hpp"
 
 #include "opencv2/core/openvx/ovx_defs.hpp"
+#include "opencv2/core/utils/logger.hpp"
 
 #include "filter.hpp"
 
@@ -66,6 +67,11 @@ namespace cv {
 #include "smooth.simd.hpp"
 #include "smooth.simd_declarations.hpp" // defines CV_CPU_DISPATCH_MODES_ALL=AVX2,...,BASELINE based on CMakeLists.txt content
 
+#include <iostream>
+#include <rzv2ma_drp.h>
+
+#include <unistd.h>
+
 namespace cv {
 
 /****************************************************************************************\
@@ -608,17 +614,298 @@ static bool validateGaussianBlurKernel(std::vector<T>& kernel)
     return isValid;
 }
 
+/***********************************************************
+* Method Name   : GaussianBlur_drp
+* Description   : to execute GaussianBlur_drp
+* Arguments     : src_mat = input Mat object, dst_mat = output Mat object
+*               : ksize = kernel size
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+************************************************************/
+int GaussianBlur_drp(Mat src_mat, Mat dst_mat, Size ksize, double sigma1, double sigma2, int borderType)
+{
+    uint32_t src_width = src_mat.cols;
+    uint32_t src_height = src_mat.rows;
+    uint32_t dst_width = src_width;
+    uint32_t dst_height = src_height;
+
+     /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_GAUSSIAN);
+
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    CV_LOG_INFO(nullptr, "GaussianBlur_drp start.");
+
+    uint16_t src_ch = src_mat.channels();
+    uint8_t *out_image_buffer;
+
+    /* to check can exec condition */
+    /* If channel = 1, src width >= 16 and src width < 3840 */
+    if(1 == src_mat.channels())
+    {
+        if(3840 < src_width || 16 > src_width)
+        {
+            return DRP_NOT_EXECUTE;
+        }
+    }
+    /* If channel != 1, src width >= 16, src width < 3840, and src width = Even */
+    else
+    {
+        if(3840 < src_width || 16 > src_width || 1 == src_width % 2)
+        {
+            return DRP_NOT_EXECUTE;
+        }
+    }
+
+    /* If channel = 1, src height >= 16 and src height < 2160 */
+    if(1 == src_mat.channels())
+    {
+        if(2160 < src_height || 16 > src_height)
+        {
+            return DRP_NOT_EXECUTE;
+        }
+    }
+    /* If channel != 1, src height >= 16, src height < 2160, and src height = Even */
+    else
+    {
+        if(2160 < src_height || 16 > src_height || 1 == src_height % 2)
+        {
+            return DRP_NOT_EXECUTE;
+        }
+    }
+
+
+    /* src image size */
+    if(3840*2160 < src_width*src_height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* when dst cols != 0 */
+    if(0 != dst_mat.cols)
+    {
+        /* If channel = 1, dst width >= 16 */ 
+        if(1 == src_mat.channels())
+        {
+           if(16 > dst_mat.cols)
+            {
+                return DRP_NOT_EXECUTE;
+            } 
+        }
+        /* If channel != 1, dst width >= 16 and dst width = Even */ 
+        else
+        {
+            if(16 > dst_mat.cols || 1 == dst_mat.cols % 2)
+            {
+                return DRP_NOT_EXECUTE;
+            }
+        }
+          
+        /* src width = dst width*/
+        if(src_width != (uint32_t)dst_mat.cols)
+        {
+            return DRP_NOT_EXECUTE;
+        }
+    }
+
+    /* when dst rows != 0 */
+    if(0 != dst_mat.rows)
+    {
+        /* If channel = 1, dst width >= 16 */ 
+        if(1 == src_mat.channels())
+        {
+            if(16 > dst_mat.rows)
+            {
+                return DRP_NOT_EXECUTE;
+            } 
+        }
+        /* If channel != 1, dst width >= 16 and dst width = Even*/ 
+        else
+        {
+            if(16 > dst_mat.rows || 1 == dst_mat.rows % 2)
+            {
+                return DRP_NOT_EXECUTE;
+            }
+        }
+
+        /* src height = dst height */
+        if(src_width != (uint32_t)dst_mat.cols)
+        {
+            return DRP_NOT_EXECUTE;
+        }
+    }
+
+    /* dst image size */
+    if(3840*2160 < dst_mat.cols*dst_mat.rows)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if(1 > src_mat.channels() || 4 < src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(src_mat.channels() != dst_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if(CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;   
+    }
+
+    /* check kernel size */
+    if( !((3 == ksize.width && 3 == ksize.height) ||
+           (5 == ksize.width && 5 == ksize.height) ||
+           (7 == ksize.width && 7 == ksize.height)) ) 
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* check sigma-x sigma-y */
+    /* If channel = 1 and (ksize.width, ksize.height) = (7,7), (sigma-x, sigma-y) = (0, 0) or (2, 2) */ 
+    if((1 == src_mat.channels()) && (7 == ksize.width && 7 == ksize.height))
+    {
+        if(!(( 0.0 == sigma1 && 0.0 == sigma2) || ( 2.0 == sigma1 && 2.0 == sigma2)))
+        {
+            return DRP_NOT_EXECUTE;
+        }
+    }
+    /* Otherwise, (sigma-x, sigma-y) = (0, 0) */
+    else
+    {
+        if( 0.0 != sigma1 || 0.0 != sigma2)
+        {
+            return DRP_NOT_EXECUTE;
+        }
+    }
+
+    /* bordertype */
+    if((BORDER_DEFAULT != borderType) || (BORDER_REFLECT_101 != borderType))
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* start drp process */
+    int result = DRP_NORMAL_END;
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    /* set in process flag */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        drp->conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    uint16_t kernel_size;
+    kernel_size = ksize.width;
+
+    /* to set resize parameter */
+    result = drp->setGaussianParameter(src_width, src_height, src_ch, kernel_size);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+    
+    result = drp->setSrcImage(src_mat.data);
+
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->execDRP();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    out_image_buffer = new uint8_t[src_width * src_height * src_ch];
+
+    result = drp->readDstImage(out_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat dst_mat_out = Mat(dst_height, dst_width, src_mat.type(), out_image_buffer);
+    dst_mat_out.copyTo(dst_mat);
+
+    delete[] out_image_buffer;
+
+    CV_LOG_INFO(nullptr, "GaussianBlur_drp end.");
+
+    drp->set_drp_end();
+  
+    /* return normal end */
+    return result;
+}
+
 void GaussianBlur(InputArray _src, OutputArray _dst, Size ksize,
                   double sigma1, double sigma2,
                   int borderType)
 {
     CV_INSTRUMENT_REGION();
 
+    /* exec drp function */
+    int ret_drp = DRP_NORMAL_END;
+
     CV_Assert(!_src.empty());
 
+    /* it is nesessary to create dst mat object. */
     int type = _src.type();
     Size size = _src.size();
     _dst.create( size, type );
+    
+    /* convert to mat object (it needs to do after dst created.)*/
+    Mat src_mat_drp = _src.getMat();
+    Mat dst_mat_drp = _dst.getMat();
+
+    ret_drp = GaussianBlur_drp(src_mat_drp, dst_mat_drp, ksize, sigma1, sigma2, borderType);    
+    Mat dst_mat_out =  Mat(src_mat_drp.rows, src_mat_drp.cols, src_mat_drp.type(), dst_mat_drp.data);
+    dst_mat_out.copyTo(_dst);
+
+    if(DRP_NORMAL_END == ret_drp)
+    {
+        return;
+    }
+
+    /* following to exec normal OpenCV function */
+    /* it needs created dst mat object. */
+
+    CV_LOG_INFO(nullptr, "GaussianBlur opencv normal process.");
 
     if( (borderType & ~BORDER_ISOLATED) != BORDER_CONSTANT &&
         ((borderType & BORDER_ISOLATED) != 0 || !_src.getMat().isSubmatrix()) )
diff --git a/modules/imgproc/src/templmatch.cpp b/modules/imgproc/src/templmatch.cpp
index 67845e7..248489b 100644
--- a/modules/imgproc/src/templmatch.cpp
+++ b/modules/imgproc/src/templmatch.cpp
@@ -42,6 +42,9 @@
 #include "precomp.hpp"
 #include "opencl_kernels_imgproc.hpp"
 
+#include <rzv2ma_drp.h>
+#include <opencv2/core/utils/logger.hpp>
+
 ////////////////////////////////////////////////// matchTemplate //////////////////////////////////////////////////////////
 
 namespace cv
@@ -1155,6 +1158,176 @@ static bool ipp_matchTemplate( Mat& img, Mat& templ, Mat& result, int method)
 
 ////////////////////////////////////////////////////////////////////////////////////////////////////////
 
+/*****************************************
+* Method Name   : matchTemplate_drp
+* Description   : to exec drp process of OpenCV accelerator matchTemplate.
+* Arguments     : _img = src image, _templ = template image, _result = result image,
+                  method = match method, _mask = mask,
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+******************************************/
+int cv::matchTemplate_drp(InputArray _img, InputArray _templ, OutputArray _result, int method, InputArray _mask)
+{
+    CV_LOG_INFO(nullptr, "matchTemplate_drp start.");
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if (NULL == drp)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_MATCHTEMPLATE);
+    
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        CV_LOG_INFO(nullptr, "matchTemplate disable.");
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* exec drp function process */
+    Mat img = _img.getMat(), templ = _templ.getMat();
+
+    /* first, check can exec drp circuit */
+    uint32_t image_width = img.cols;
+    uint32_t image_height = img.rows;
+    uint32_t tmpl_width = templ.cols;
+    uint32_t tmpl_height = templ.rows;
+    uint32_t tmpl_ch = templ.channels();
+
+    uint16_t image_ch = img.channels();
+    uint8_t *out_image_buffer;
+
+    /* image width */
+    if (1920 < image_width || 16 > image_width || 0 != image_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* image height */
+    if (1080 < image_height || 16 > image_height || 0 != image_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if (1 > image_ch || 4 < image_ch)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if (CV_8U != img.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* templ width */
+    if (image_width < tmpl_width || 8 > tmpl_width || 0 != tmpl_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* templ height */
+    if (image_height < tmpl_height || 8 > tmpl_height || 0 != tmpl_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* method */
+    if(method != CV_TM_SQDIFF && method != CV_TM_SQDIFF_NORMED
+        && method != CV_TM_CCORR && method != CV_TM_CCORR_NORMED)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* mask */
+    if (&_mask != &noArray())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat result_mat = _result.getMat();
+    int result = DRP_NORMAL_END;
+
+    /* check continuous */
+    if(!img.isContinuous())
+    {
+        img = img.clone();
+    }
+
+    if(!templ.isContinuous())
+    {
+        templ = templ.clone();
+    }
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->setMatchTemplateParameter(image_width, image_height, image_ch,
+                tmpl_width, tmpl_height, tmpl_ch, method);
+
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->setSrcImage(img.data);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->setMatchTempl(templ.data);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->execDRP();
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    uint32_t result_size = result_mat.cols * result_mat.rows * result_mat.channels();
+    out_image_buffer = (uint8_t *)(new uint32_t[result_size]);
+    
+    result = drp->readTemplateMatchResult(out_image_buffer);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat dst_mat_out = Mat(result_mat.rows, result_mat.cols, result_mat.type(), out_image_buffer);
+    dst_mat_out.copyTo(_result);
+
+    delete[] out_image_buffer;
+
+    CV_LOG_INFO(nullptr, "matchTemplate_drp end.");
+
+    drp->set_drp_end();
+
+    return result;
+}
+
 void cv::matchTemplate( InputArray _img, InputArray _templ, OutputArray _result, int method, InputArray _mask )
 {
     CV_INSTRUMENT_REGION();
@@ -1187,6 +1360,15 @@ void cv::matchTemplate( InputArray _img, InputArray _templ, OutputArray _result,
     Mat result = _result.getMat();
 
     CV_IPP_RUN_FAST(ipp_matchTemplate(img, templ, result, method))
+    
+    int ret = matchTemplate_drp(_img, _templ, _result, method, _mask);
+
+    if(ret != DRP_NOT_EXECUTE)
+    {
+	 return;
+    }
+
+    CV_LOG_INFO(nullptr, "continue to normal opencv.");
 
     crossCorr( img, templ, result, Point(0,0), 0, 0);
 
diff --git a/modules/imgproc/src/thresh.cpp b/modules/imgproc/src/thresh.cpp
index 4622691..16b8aec 100644
--- a/modules/imgproc/src/thresh.cpp
+++ b/modules/imgproc/src/thresh.cpp
@@ -46,6 +46,9 @@
 
 #include "opencv2/core/openvx/ovx_defs.hpp"
 
+#include <opencv2/core/utils/logger.hpp>
+#include <rzv2ma_drp.h>
+
 namespace cv
 {
 
@@ -1664,12 +1667,189 @@ double cv::threshold( InputArray _src, OutputArray _dst, double thresh, double m
     return thresh;
 }
 
+/***************************************************************************
+* Method Name   : cv::adaptiveThreshold_drp
+* Description   : to execute adaptiveThreshold_drp
+* Arguments     : _src = input Mat object, _dst = output Mat object,
+                  max_value = max value condition is satisfiled,
+                  threshold_type = thresholding type, block_size = size of block size of pixel
+                  threshold_C = Constant substracted
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+****************************************************************************/
+int cv::adaptiveThreshold_drp( InputArray _src, OutputArray _dst, double max_value,
+    int adaptive_method, int threshold_type, int block_size, double threshold_c )
+{
+    CV_LOG_INFO(nullptr, "adaptiveThreshold_drp start.");
+
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_ATHRESHOLD);
+
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* exec drp function process */
+    /* convert to mat object */
+    Mat src_mat = _src.getMat();
+
+    /* first, check can exec drp circuit */
+    uint32_t src_width = src_mat.cols;
+    uint32_t src_height = src_mat.rows;
+    uint32_t dst_width = src_width;
+    uint32_t dst_height = src_height;
+    uint16_t src_ch = src_mat.channels();
+    uint8_t *out_image_buffer;
+
+    /* width */
+    if (3840 < src_width || 16 > src_width || 0 != src_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* height */
+    if (2160 < src_height || 16 > src_height || 0 != src_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if (1 != src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if (CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* maxValue */
+    if (0 > max_value || 255 < max_value)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* adaptiveMethod */
+    if(adaptive_method != ADAPTIVE_THRESH_MEAN_C)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* thesholdType */
+    if( (threshold_type != THRESH_BINARY) && (threshold_type != THRESH_BINARY_INV) )
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (3 > block_size || 255 < block_size || (int)src_width <= block_size || (int)src_height <= block_size || 1 != block_size % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(threshold_c < 0.0 || threshold_c > 255.0)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+    /* get 8bit of decimal point, truncate rest */
+    uint16_t threshold_c_16 = static_cast<uint16_t>(std::round(threshold_c * (1 << 8)));
+
+    CV_LOG_INFO(nullptr, "adaptiveThreshold_drp exec.");
+
+    /* it is nesessary to create dst mat object. */
+    _dst.create(src_mat.size(), CV_MAKETYPE(src_mat.depth(), src_ch));
+    Mat dst_mat = _dst.getMat();
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    int result = DRP_NORMAL_END;
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* set parameter to drp */
+    drp->setAdaptiveThreshold(src_width, src_height, src_ch, max_value, threshold_type, block_size, threshold_c_16);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->setSrcImage(src_mat.data);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->execDRP();
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    out_image_buffer = new uint8_t[src_width * src_height * src_ch];
+
+    result = drp->readDstImage(out_image_buffer);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat dst_mat_out = Mat(dst_height, dst_width, CV_MAKETYPE(src_mat.depth(), src_ch), out_image_buffer);
+    dst_mat_out.copyTo(dst_mat);
+
+    delete[] out_image_buffer;
+
+    CV_LOG_INFO(nullptr, "adaptiveThreshold_drp end.");
+
+    drp->set_drp_end();
+
+    return result;
+}
 
 void cv::adaptiveThreshold( InputArray _src, OutputArray _dst, double maxValue,
                             int method, int type, int blockSize, double delta )
 {
     CV_INSTRUMENT_REGION();
 
+    /* first, exec drp function */
+    int ret = cv::adaptiveThreshold_drp(_src, _dst, maxValue, method, type, blockSize, delta);
+    if(ret != DRP_NOT_EXECUTE)
+    {
+        CV_LOG_INFO(nullptr, "adaptiveThreshold_drp nornal end.");
+        return;
+    }
+
+    CV_LOG_INFO(nullptr, "adaptiveThreshold exec nornal opencv.");
+
     Mat src = _src.getMat();
     CV_Assert( src.type() == CV_8UC1 );
     CV_Assert( blockSize % 2 == 1 && blockSize > 1 );
diff --git a/modules/imgproc/src/utils.cpp b/modules/imgproc/src/utils.cpp
index 4f45cde..b27990c 100644
--- a/modules/imgproc/src/utils.cpp
+++ b/modules/imgproc/src/utils.cpp
@@ -40,6 +40,7 @@
 //M*/
 
 #include "precomp.hpp"
+#include <rzv2ma_drp.h>
 
 CV_IMPL CvSeq* cvPointSeqFromMat( int seq_kind, const CvArr* arr,
                                   CvContour* contour_header, CvSeqBlock* block )
@@ -87,4 +88,61 @@ cvCopyMakeBorder( const CvArr* srcarr, CvArr* dstarr, CvPoint offset,
     cv::copyMakeBorder( src, dst, top, bottom, left, right, borderType, value );
 }
 
+/*****************************************************************
+* Method Name   : OCA_Activate
+* Description   : activate or inactivate opencva circuit function
+* Arguments     : unsigned long* OCA_list
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+******************************************************************/
+CV_EXPORTS_W int OCA_Activate(unsigned long* OCA_list)
+{
+    /* get instance for exec api */
+    rzv2m_drp *drp = rzv2m_drp::get_instance_forapi();
+    if(drp == NULL)
+    {
+        return -1;
+    }
+
+    /* reading opencva binary header info */
+    int result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+    
+    /* call method */
+    drp->OCA_Activate(OCA_list);
+    
+    return 0;
+}
+
+/*****************************************************************
+* Method Name   : OCA_ConflictNotification
+* Description   : set conflict ation setting(CV_Error or normal opencv exec)
+* Arguments     : int OCA_list
+* Return value  : void
+******************************************************************/
+CV_EXPORTS_W void OCA_ConflictNotification(int oca_conflict)
+{
+    /* get instance for exec api */
+    rzv2m_drp *drp = rzv2m_drp::get_instance_forapi();
+    if(drp == NULL)
+    {
+        return;
+    }
+
+    /* reading opencva binary header info */
+    int result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        return;
+    }
+
+    /* call method */
+    drp->OCA_ConflictNotification(oca_conflict);
+
+    return;
+}
+
 /* End of file. */
